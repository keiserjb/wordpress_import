<?php

/**
 * @file
 * Wordpress module
 *
 * This module allow to import a blog form a WXR file generated by Worpdress
 */

/*
  Wordpress Import Drupal module : Import a Wordpress WXR file into Drupal
  Copyright (C) 2007 Yann Rocq <yann@rocq.net> - http://www.rocq.net/yann/

  This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License along
  with this program; if not, write to the Free Software Foundation, Inc.,
  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  */

/**
 * Implementation of hook_menu()
 */
function wordpress_import_menu() {
  $items = array();

  $items['admin/content/wordpress_import'] = array(
    'title' => 'Wordpress import',
    'description' => 'Import Wordpress WXR file',
    'page callback' => 'wordpress_import_home',
    'access arguments' => array('import wordpress blog'),
    );
  $items['admin/content/wordpress_import/rollback'] = array(
    'title' => 'Wordpress import rollback',
    'type' => MENU_LOCAL_TASK,
    'description' => 'Rollback last Wordpress Import',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('wordpress_rollback_form'),
    'access arguments' => array('import wordpress blog'),
    'weight' => 1,
    );
  $items['admin/content/wordpress_import/rollback_edit'] = array(
    'title' => 'Wordpress import edit rollbacks',
    'type' => MENU_LOCAL_TASK,
    'description' => 'Edit Rollbacks',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('wordpress_rollback_edit_form'),
    'access arguments' => array('import wordpress blog'),
    'weight' => 2,
    );

  return $items;
}

/**
 * Implements hook_permission().
 *
 * @return array permissions
 **/
function wordpress_import_permission() {
  return array(
    'import wordpress blog' => array(
      'title' => t('Import wordpress blog'),
      'description' => t('Permission to import a wordpress blog.'),
    ),
  );
}

/**
 * Module entry point
 */
function wordpress_import_home() {

  // XMLReader is required
  if (!extension_loaded('xmlreader')) {
    backdrop_set_message(t('<strong>XMLReader PHP extension not found!</strong>  The XMLReader extension is available in PECL as of PHP 5.0.0 and is included and enabled as of PHP 5.1.0 by default. It can be enabled by adding the argument --enable-xmlreader  (or --with-xmlreader before 5.1.0) to your configure line. The libxml  extension is required. '), 'error');
    return '';
  }

  return wordpress_import_wizard();
}

/**
 * Create and manage the multistep form
 */
function wordpress_import_wizard() {
  $step = arg(3);

//  ctools_include('wizard');
//  ctools_include('object-cache');

  // *** SETUP ARRAY multistep setup ****
  $form_info = array(
    'id' => 'wordpress_import',
    'path' => "admin/content/wordpress_import/%step",
    'show trail' => TRUE,
    'show back' => FALSE,
    'show cancel' => TRUE,
    'show return' => FALSE,
    'next text' => t('Next'),
    'next callback' =>  'wordpress_import_form_subtask_next',
    'finish callback' => 'wordpress_import_form_subtask_finish',
    'return callback' => 'wordpress_import_form_subtask_finish',
    'cancel callback' => 'wordpress_import_form_subtask_cancel',
    'ajax' => FALSE,
   // this controls order, as well as form labels
    'order' => array(
      'file' => t('Source file'),
      'options' => t('Options'),
      'taxonomy' => t('Map taxonomies'),
      'og' => t('Organic groups'),
      'mapusers' => t('Map users'),
      'newusers' => t('New users'),
      'ready' => t('Ready'),
    ),
   // here we map a step to a form id.
    'forms' => array(
      'file' => array(
        'form id' => 'wordpress_import_form_file'
      ),
      'options' => array(
        'form id' => 'wordpress_import_form_options'
      ),
      'taxonomy' => array(
        'form id' => 'wordpress_import_form_map_taxonomies'
      ),
      'og' => array(
        'form id' => 'wordpress_import_form_og'
      ),
      'mapusers' => array(
        'form id' => 'wordpress_import_form_mapusers'
      ),
      'newusers' => array(
        'form id' => 'wordpress_import_form_newusers'
      ),
      'ready' => array(
        'form id' => 'wordpress_import_form_ready'
      ),
    ),
  );

  // *** SETTING THE FORM UP FOR MULTISTEP *** //
  $form_state = array(
    // 'cache name' => NULL,
    'cache name' => '',
  );

  $wordpress_import = wordpress_import_form_get_page_cache('');
  // $wordpress_import = NULL;

  if (!$wordpress_import && $step != '') {
    backdrop_goto('admin/content/wordpress_import');
    return;
  }

  if (!$wordpress_import) {
    backdrop_set_message($step);
    $step = current(array_keys($form_info['order']));
    $wordpress_import = new stdClass();
    // ctools_object_cache_set('wordpress_import', $form_state['cache name'], $wordpress_import);
    wordpress_import_form_set_page_cache($form_state['cache name'], $wordpress_import);
  }

  $form_state['wordpress_import_obj'] = $wordpress_import;

  // Skip taxonomy mapping form if taxonomy import is deselected
  if ($step == 'taxonomy' && !!$wordpress_import->options['disable_categories']) {
    backdrop_goto('admin/content/wordpress_import/og');
  }

  // Skip OG step if module isn't present, or if node content type isn't an OG-enabled
  if ($step == 'og' && (!module_exists('og') || !($wordpress_import->options['nodetype_post_og'] || $wordpress_import->options['nodetype_page_og']))) {
    backdrop_goto('admin/content/wordpress_import/mapusers');
  }

  // Skip users creation step if no new users
  if ($step == 'newusers' && !array_search('newuser', $wordpress_import->usermap)) {
    backdrop_goto('admin/content/wordpress_import/ready');
  }

  // $output = ctools_wizard_multistep_form($form_info, $step, $form_state);
  $output = form_wizard_multistep_form($form_info, $step, $form_state);
  return $output;
}


/*---------------- Bachdrop cache handling functions ------------ */

/**
 * Remove an item from the object cache.
 */
function wordpress_import_form_clear_page_cache($name) {
  // ctools_object_cache_clear('wordpress_import', $name);
  tempstore_clear('wordpress_import', $name);
}

/**
 * Get the cached changes to a given task handler.
 */
function wordpress_import_form_get_page_cache($name) {
  // $cache = ctools_object_cache_get('wordpress_import', $name);
  $cache = tempstore_get('wordpress_import', $name);
  return $cache;
}

/**
 * Store changes to a task handler in the object cache.
 */
function wordpress_import_form_set_page_cache($name, $page) {
  $cache = tempstore_set('wordpress_import', $name, $page, REQUEST_TIME + 3600);
}


/*-------------------------- Form Steps  ---------------------- */

/**
 * First form step:
 * Handling of the WXR file. Either upload a file or select
 * an already uploaded file stored in the created folder.
 */
function wordpress_import_form_file($form, &$form_state) {
  global $base_path;

  $wordpress_import = &$form_state['wordpress_import_obj'];

  $form['informations'] = array(
   '#value' => t('This module will import a Wordpress eXtended RSS (WXR) file generated by Wordpress. If you need instructions on creating this file, please read the  <a href="@codex">documentation</a>. <em>You must make a backup copy of your Drupal database before proceeding!</em>', array('@codex' => url('http://codex.wordpress.org/Tools_Export_SubPanel')))
  );

  $form['import_id'] = array(
    '#type' => 'textfield',
    '#title' => t('Give this import a unique title.'),
    '#description' => t('Select a unique title to this import to detect it on rollback.'),
  );

  // Upload file form element
  $form['upload'] = array(
    '#type' => 'file',
    '#title' => t('Upload your WXR file'),
    '#size' => 40,
    '#description' => t('The file can\'t exceed %maximum megabytes', array('%maximum' => $base_path . file_upload_max_size()/1024/1024)),
  );

  // Create and scan module directory
  $directory = 'public://wordpress';
  $wordpress_import_path = backdrop_realpath($directory);
  $erg = file_prepare_directory($directory, FILE_CREATE_DIRECTORY);
  $files = file_scan_directory($wordpress_import_path, '/.*.xml$/i');

  if (count($files) > 0) {
    foreach ($files as $file) {
      $options[$file->filename] = $file->filename;
    }
    ksort($options);
    $description = '';
  }
  else {
    $options = array();
    $description = t('No files found in %directory', array('%directory' => file_create_url('files/wordpress')));
  }

  // Local file selector element
  $form['local'] = array(
      '#title' => t('Or, alternatively, select a local WXR file'),
      '#type' => 'radios',
      '#description' => $description,
      '#options' => $options
    );

  $form['#attributes'] = array('enctype' => "multipart/form-data");

  // $form_state['no buttons'] = TRUE;

  return $form;
}


/**
 * Validation of the first firm step.
 */
function wordpress_import_form_file_validate(&$form, &$form_state) {

  if ($form_state['clicked_button']['#wizard type'] == 'cancel') {
    return;
  }

  // Process uploaded file (if any), and set file path
  $directory = 'public://wordpress';
  $validators = array('file_validate_extensions' => array('xml'));
  $upload = file_save_upload('upload', $validators, $directory);
  if ($upload) {
    $form_state['values']['upload'] = $upload->filename;
    $filepath = backdrop_realpath($upload->uri);
  }
  else {
    $filepath = backdrop_realpath('public://wordpress') . '/' . $form_state['values']['local'];
  }

  if (empty($form_state['values']['import_id'])) {
    form_set_error('import_id', t('You must specify a title for this import.'));
    return;
  }

  // Make sure a file was uploaded or a local file was selected
  if (empty($form_state['values']['upload']) && empty($form_state['values']['local'])) {
    form_set_error('upload', t('You must specify a WXR file to upload or select a local WXR file. If you attempted to upload a file, the operation may have failed.'));
    return;
  }
  else {
    $form_state['wordpress_import_obj']->filepath = $filepath;
  }

  if (!wordpress_import_read_wxr($form_state['wordpress_import_obj'])) {
    form_set_error('upload', t('<strong>This file does not appear to be a valid WXR file.</strong> The file is either corrupted or invalid XML. In some versions of WordPress, the export function can produce malformed XML. Please see README.txt (included in the module archive) for further guidance.'));
  }

}


/**
 * Submit handler of the first form step.
 */
function wordpress_import_form_file_submit(&$form, &$form_state) {
  (!empty($form_state['values']['upload'])) ? ($filesource = t('uploaded')) : ($filesource = t('local'));
  $fileinfo = pathinfo($form_state['wordpress_import_obj']->filepath);

  backdrop_set_message(t('Successfully loaded @filesource file "@filename".', array('@filesource' => $filesource, '@filename' => $fileinfo['basename'])));

  $message = t('The following elements were identified :');

  $msg_found = array();
  $msg_found[] = '<li>' . t('@found_posts posts/pages', array('@found_posts' => $form_state['wordpress_import_obj']->count['posts'])) . '</li>';
  $msg_found[] = '<li>' . t('@found_comments comments', array('@found_comments' => $form_state['wordpress_import_obj']->count['comments'])) . '</li>';
  $msg_found[] = '<li>' . t('@found_authors authors', array('@found_authors' => count($form_state['wordpress_import_obj']->count['author_posts']))) . '</li>';
  $msg_found[] = '<li>' . t('@found_categories categories', array('@found_categories' => $form_state['wordpress_import_obj']->count['categories'])) . '</li>';
  $msg_found[] = '<li>' . t('@found_tags tags', array('@found_tags' => $form_state['wordpress_import_obj']->count['tags'])) . '</li>';

  backdrop_set_message($message . '<ul>' . join("\n", $msg_found) . '</ul>');

  // create database entry
  $iid = wordpress_import_db_create($form_state['values']['import_id']);
  $form_state['wordpress_import_obj']->import_id = $iid;
}


/**
 * Second form step:
 * Set options and advanced import options.
 * Options are:
 *     content type mapping
 *     language selection
 *     select, what to import
 *     choose creation of path alias or redirects
 */
function wordpress_import_form_options($form, &$form_state) {
  $wordpress_import = &$form_state['wordpress_import_obj'];

  $form['basic_options'] = array(
    '#type' => 'fieldset',
    '#title' => t('Options'),
    '#collapsible' => FALSE,
    '#tree' => TRUE
  );

  // Post content type
  $node_types = node_type_get_types();
  $content_types = array('' => '', 'noimport' => t('Don\'t import'));
  foreach ($node_types as $k => $v) {
      if (!module_exists('og') || (module_exists('og') && !og_is_group_type($k))) {
        $content_types[$k] = $v->name;
      }
  }

  // find text formats
  $content_formats = array('' => '');
  $formats = filter_formats();
  foreach ($formats as $format) {
    $content_formats[$format->format] = $format->name;
  }

  // find all menus
  $available_menus = array('' => '') + menu_get_menus();

  $form['basic_options']['nodetype_post'] = array(
    '#type' => 'select',
    '#title' => t('Import posts in content type'),
    '#description' => t('All imported posts will be assigned the selected content type.'),
    '#default_value' => '',
    '#options' => $content_types,
    );
  $form['basic_options']['nodetype_post_format'] = array(
    '#type' => 'select',
    '#title' => t('Import posts in text format'),
    '#description' => t('All imported posts will be imported with the selected text format.'),
    '#default_value' => '',
    '#options' => $content_formats,
    );
  $form['basic_options']['nodetype_page'] = array(
    '#type' => 'select',
    '#title' => t('Import pages in content type'),
    '#description' => t('All imported pages will be assigned the selected content type.'),
    '#default_value' => '',
    '#options' => $content_types,
    );
  $form['basic_options']['nodetype_page_format'] = array(
    '#type' => 'select',
    '#title' => t('Import pages in text format'),
    '#description' => t('All imported pages will be imported with the selected text format.'),
    '#default_value' => '',
    '#options' => $content_formats,
    );

  $form['basic_options']['comments_format'] = array(
    '#type' => 'select',
    '#title' => t('Comments text format'),
    '#description' => t('Select the input format to use for imported comments.'),
    '#default_value' => '',
    '#options' => $content_formats,
  );

  $form['basic_options']['create_menu_items_page'] = array(
    '#type' => 'checkbox',
    '#title' => t('Create menu items for imported pages?'),
    '#default_value' => FALSE,
    '#disabled' => FALSE,
    '#description' => t('Check this box to if you want to create menu items for the imported pages'),
  );
  $form['basic_options']['create_menu_items_page_menu'] = array(
    '#type' => 'select',
    '#title' => t('Create menu item in menu'),
    '#description' => t('Select, in what menu the items should be created.'),
    '#default_value' => '',
    '#options' => $available_menus,
    );

  if (module_exists('locale')) {
    $default = language_default();
    $options = array('' => t('Language neutral'));
    $language_list = language_list();
    foreach ($language_list as $value) {
      $options[$value->langcode] = $value->name;
    }
    $form['basic_options']['language'] = array(
      '#type' => 'select',
      '#title' => t('Language'),
      '#default_value' => $default->langcode,
      '#options' => $options,
    );
  }

  $form['basic_options']['usermap_type'] = array(
      '#title' => t('User mapping'),
      '#type' => 'radios',
      '#description' => t('<strong>Single user</strong> will import all posts as one specified Drupal user. <strong>Manual</strong> permits the mapping of an existing or new Drupal user to each Wordpress author.'),
      '#options' => array(
        'default' => t('Single user'),
        'manual' => t('Manual'))
    );

  $form['advanced_options'] = array(
    '#type' => 'fieldset',
    '#title' => t('Advanced options'),
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
    '#tree' => TRUE
  );

  $form['advanced_options']['disable_categories'] = array(
    '#type' => 'checkbox',
    '#title' => t('Don\'t import categories and tags'),
    '#default_value' => FALSE,
    '#disabled' => FALSE,
    '#description' => t('Check this box to disable import of categories and tags')
  );

  $form['advanced_options']['disable_comments'] = array(
    '#type' => 'checkbox',
    '#title' => t('Don\'t import comments'),
    '#default_value' => FALSE,
    '#disabled' => FALSE,
    '#description' => t('Check this box to disable import of comments')
  );

  $form['advanced_options']['disable_trackbacks'] = array(
    '#type' => 'checkbox',
    '#title' => t('Don\'t import trackbacks'),
    '#default_value' => FALSE,
    '#disabled' => FALSE,
    '#description' => t('Check this box to disable import of trackbacks')
  );

  $form['advanced_options']['aliases'] = array(
    '#type' => 'checkbox',
    '#title' => t('Create path aliases'),
    '#default_value' => FALSE,
    '#disabled' => FALSE,
    '#description' => t('Preserve the path of the original Wordpress posts and pages. For this to work properly, your Drupal site root must be the same as the Wordpress site (!root) and clean URLs should be activated', array('!root' => $wordpress_import->data['baseurl']))
  );

  $form['advanced_options']['redirect'] = array(
    '#type' => 'checkbox',
    '#title' => t('Create URL redirect'),
    '#default_value' => FALSE,
    '#disabled' => FALSE,
    '#description' => t('Create an redirect of the original Wordpress posts and pages URLs. For this to work properly, your Drupal site root must be the same as the Wordpress site (!root) and clean URLs should be activated', array('!root' => $wordpress_import->data['baseurl']))
  );


  $form['advanced_options']['images'] = array(
    '#type' => 'checkbox',
    '#title' => t('Transfer images'),
    '#default_value' => FALSE,
    '#description' => t('Try to download the images referenced in the blog posts locally')
  );

  $form['advanced_options']['images_dir'] = array(
    '#type' => 'textfield',
    '#title' => t('Images directory'),
    '#default_value' => '/wp_images',
    '#description' => t('Subdirectory of <strong>@wordpress_import_file_directory_path</strong> in which to place files, must start with /', array('@wordpress_import_file_directory_path' => wordpress_import_file_directory_path())),
  );

  // Warn if some key modules are not found
  if (!module_exists('taxonomy')) {
      backdrop_set_message(t('Could not find module "path". <strong>Categories and tags will not be imported.</strong>'), 'error');
      $form['advanced_options']['disable_categories']['#default_value'] = TRUE;
      $form['advanced_options']['disable_categories']['#disabled'] = TRUE;
      $form['advanced_options']['#collapsed'] = FALSE;
  }
  if (!module_exists('comment')) {
      backdrop_set_message(t('Could not find module "comment". <strong>Comments and tackbacks will not be imported.</strong>'), 'error');
      $form['advanced_options']['disable_comments']['#default_value'] = TRUE;
      $form['advanced_options']['disable_comments']['#disabled'] = TRUE;
      $form['advanced_options']['#collapsed'] = FALSE;
  }
  if (!module_exists('trackback')) {
      backdrop_set_message(t('Could not find module "trackback". <strong>Trackbacks will not be imported.</strong>'), 'error');
      $form['advanced_options']['disable_trackbacks']['#default_value'] = TRUE;
      $form['advanced_options']['disable_trackbacks']['#disabled'] = TRUE;
      $form['advanced_options']['#collapsed'] = FALSE;
  }
  if (!module_exists('path')) {
      backdrop_set_message(t('Could not find module "path". Create paths option disabled.'), 'warning');
      $form['advanced_options']['aliases']['#default_value'] = FALSE;
      $form['advanced_options']['aliases']['#disabled'] = TRUE;
  }
  if (!module_exists('redirect')) {
      backdrop_set_message(t('Could not find module "redirect". Create redirect option disabled.'), 'warning');
      $form['advanced_options']['redirect']['#default_value'] = FALSE;
      $form['advanced_options']['redirect']['#disabled'] = TRUE;
  }
  if (!extension_loaded('curl')) {
      backdrop_set_message(t('cURL PHP extension not available. Transfer images option disabled.'), 'warning');
      $form['advanced_options']['images']['#default_value'] = FALSE;
      $form['advanced_options']['images']['#disabled'] = TRUE;
  }

  return $form;
}


/**
 * Validation of second form step.
 */
function wordpress_import_form_options_validate(&$form, &$form_state) {

  if ($form_state['clicked_button']['#wizard type'] == 'cancel') {
    return;
  }

  if (empty($form_state['values']['basic_options']['nodetype_post'])) {
    form_set_error('basic_options][nodetype', t('You must specify a content type to import Wordpress posts into.'));
  }

  if (empty($form_state['values']['basic_options']['nodetype_page'])) {
    form_set_error('basic_options][nodetype', t('You must specify a content type to import Wordpress pages into.'));
  }

  if ($form_state['values']['basic_options']['create_menu_items_page']
      && empty($form_state['values']['basic_options']['create_menu_items_page_menu'])) {
    form_set_error('basic_options][create_menu_items_page_menu', t('Please select the menu, where the item should be added'));
  }

  if (empty($form_state['values']['basic_options']['nodetype_post_format'])
      && $form_state['values']['basic_options']['nodetype_post'] != 'noimport') {
    form_set_error('basic_options][nodetype_post_format', t('You must specify a format to import Wordpress posts into.'));
  }
  if (empty($form_state['values']['basic_options']['nodetype_page_format'])
      && $form_state['values']['basic_options']['nodetype_pagr'] != 'noimport') {
    form_set_error('basic_options][nodetype_page_format', t('You must specify a format to import Wordpress posts into.'));
  }


  if (empty($form_state['values']['basic_options']['usermap_type'])) {
    form_set_error('basic_options][usermap_type', t('You must specify a user mapping method.'));
  }

  // make sure that either path alias OR redirect is enabled
  if ($form_state['values']['advanced_options']['aliases'] &&
      $form_state['values']['advanced_options']['redirect']) {
    form_set_error('advanced_options][aliases', t('Make sure that either path alias OR redirect is enabled.'));
    form_set_error('advanced_options][redirect', '');
  }

  // Test if images directory is valid
  if ($form_state['values']['advanced_options']['images']) {
    $dir = wordpress_import_file_directory_path() . rtrim($form_state['values']['advanced_options']['images_dir'], '/\\');

    if (!is_dir($dir)) {
      if (!backdrop_mkdir($dir)) {
        form_set_error('advanced_options][images_dir', t('Invalid images directory specified.'));
        $form['advanced_options']['#collapsed'] = FALSE;
      }
    }
  }
  elseif (is_dir($dir)) {
    backdrop_rmdir($dir);
  }
}


/**
 * Submit handler of second form step.
 */
function wordpress_import_form_options_submit(&$form, &$form_state) {

  // Clear messages
  backdrop_get_messages();

  $form_state['values']['advanced_options']['images_dir'] = wordpress_import_file_directory_path() . rtrim($form_state['values']['advanced_options']['images_dir'], '/\\');

  $options = $form_state['values']['basic_options'] + $form_state['values']['advanced_options'];
  $form_state['wordpress_import_obj']->options = $options;

  // Verify if chosen content types are OG-enabled
  $form_state['wordpress_import_obj']->options['nodetype_post_og'] = FALSE;
  $form_state['wordpress_import_obj']->options['nodetype_page_og'] = FALSE;
  if (module_exists('og') && og_is_group_post_type($form_state['wordpress_import_obj']->options['nodetype_post'])) {
    $form_state['wordpress_import_obj']->options['nodetype_post_og'] = TRUE;
  }
  if (module_exists('og') && og_is_group_post_type($form_state['wordpress_import_obj']->options['nodetype_page'])) {
    $form_state['wordpress_import_obj']->options['nodetype_page_og'] = TRUE;
  }
}


/**
 * Third form step:
 *   Select mapping of the vocabularies.
 */
function wordpress_import_form_map_taxonomies($form, &$form_state) {
  $wordpress_import = &$form_state['wordpress_import_obj'];

  // get the node types
  $nodetype_post = $wordpress_import->options['nodetype_post'];
  $nodetype_page = $wordpress_import->options['nodetype_page'];

  // get the fields of the node type
  $nodetype_post_fields = field_info_instances('node', $nodetype_post);
  $nodetype_page_fields = field_info_instances('node', $nodetype_page);

  // find the taxonomy-fields
  $nodetype_post_taxonomy = array('noimport' => 'Do not import');
  $nodetype_page_taxonomy = array('noimport' => 'Do not import');


  foreach ($nodetype_post_fields as $field_name => $value) {
    $field_info = field_info_field($field_name);
    if (isset($field_info['type']) && ($field_info['type'] == 'taxonomy_term_reference')) {
      $nodetype_post_taxonomy[$field_name] = $value['label'];
    }
  }
/*
  foreach ($nodetype_page_fields as $field_name => $value) {
    $field_info = field_info_field($field_name);
    if (isset($field_info['type']) && ($field_info['type'] == 'taxonomy_term_reference')) {
      $nodetype_page_taxonomy[$field_name] = $value['label'];
    }
  }
*/
  $form['post_taxonomy_category'] = array(
    '#type' => 'select',
    '#title' => t('Import Category to vocabulary'),
    '#description' => t('All categories will be assigned to that vocabulary'),
    '#default_value' => 'noimport',
    '#options' => $nodetype_post_taxonomy,
  );

  $form['post_taxonomy_tags'] = array(
    '#type' => 'select',
    '#title' => t('Import Tags to vocabulary'),
    '#description' => t('All categories will be assigned to that vocabulary'),
    '#default_value' => 'noimport',
    '#options' => $nodetype_post_taxonomy,
  );
/*
  $form['page_taxonomy_category'] = array(
    '#type' => 'select',
    '#title' => t('Import Category to vocabulary'),
    '#description' => t('All categories will be assigned to that vocabulary'),
    '#default_value' => 'noimport',
    '#options' => $nodetype_page_taxonomy,
  );

  $form['page_taxonomy_tags'] = array(
    '#type' => 'select',
    '#title' => t('Import Tags to vocabulary'),
    '#description' => t('All categories will be assigned to that vocabulary'),
    '#default_value' => 'noimport',
    '#options' => $nodetype_page_taxonomy,
  );
*/
  return $form;
}


/**
 * Submit handler of third form step.
 */
function wordpress_import_form_map_taxonomies_submit(&$form, &$form_state) {

  $form_state['wordpress_import_obj']->options['nodetype_post_tm']['category_fieldname'] = $form_state['values']['post_taxonomy_category'];
  $form_state['wordpress_import_obj']->options['nodetype_post_tm']['tag_fieldname'] = $form_state['values']['post_taxonomy_tags'];

  // we additionally need to add the vocabulary name here
  $fn = $form_state['values']['post_taxonomy_category'];
  if ($fn != 'noimport') {
    $fi = field_info_field($fn);
    $form_state['wordpress_import_obj']->options['nodetype_post_tm']['category_vocabulary'] = $fi['settings']['allowed_values'][0]['vocabulary'];
  }

  $fn = $form_state['values']['post_taxonomy_tags'];
  if ($fn != 'noimport') {
    $fi = field_info_field($fn);
    $form_state['wordpress_import_obj']->options['nodetype_post_tm']['tag_vocabulary'] = $fi['settings']['allowed_values'][0]['vocabulary'];
  }

  /*
  $form_state['wordpress_import_obj']->options['nodetype_page_tm']['category_fieldname'] = $form_state['values']['page_taxonomy_category'];
  $form_state['wordpress_import_obj']->options['nodetype_page_tm']['tag_fieldname'] = $form_state['values']['page_taxonomy_tags'];
  */
}


/**
 * Fourth form step:
 * Settings for open graph. Not testet yet, because open graph is not yet
 * imported to backdrop.
 */
function wordpress_import_form_og($form, &$form_state) {
  $wordpress_import = &$form_state['wordpress_import_obj'];

  $form['informations'] = array(
   '#value' => t('You selected a content type which is also an OG group post node type. You may select OG parameters for the imported content.')
  );

  $form['og_nodeapi'] = array(
    '#type' => 'fieldset',
    '#title' => t('Organic groups'),
    '#collapsible' => FALSE,
    '#tree' => TRUE,
  );
  og_form_add_og_audience($form, $form_state);

  if (module_exists('og_access')) {
    $form['og_nodeapi']['og_public'] = array(
    '#type' => 'checkbox',
    '#title' => 'Public',
    '#description' => t('Show this post to everyone, or only to members of the groups checked above. Posts without any groups are always <em>public</em>.'),
    );
  }

  return $form;
}


/**
 * Submit handler for the open graph settings form.
 */
function wordpress_import_form_og_submit(&$form, &$form_state) {
  $form_state['wordpress_import_obj']->og_groups = $form_state['values']['og_nodeapi']['visible']['og_groups'];
  $form_state['wordpress_import_obj']->og_public = $form_state['values']['og_nodeapi']['og_public'];
}


/**
 * Form step five:
 *   Form for mapping imported user to existing user.
 */
function wordpress_import_form_mapusers($form, &$form_state) {
  $wordpress_import = &$form_state['wordpress_import_obj'];

  // Get Drupal users
  $sql = "SELECT u.uid, u.name FROM {users} u ORDER BY name ASC";
  $result =  db_query($sql);
  $found_users = $result->fetchAllAssoc('uid');

  foreach ($found_users as $backdrop_user) {
    if ($backdrop_user->uid != 0) {
      $backdrop_users[$backdrop_user->uid] = $backdrop_user->name;
    }
  }

  if ($wordpress_import->options['usermap_type'] == 'default') {

    $backdrop_users = array('newuser' => t('Create new user')) + $backdrop_users;

    $form['defaultuser'] = array(
      '#type' => 'select',
      '#title' => t('Default user'),
      '#description' => t('Map all Wordpress authors to one single Drupal user.'),
      '#options' => $backdrop_users,
    );

  }
  else {

    $backdrop_users = array('newuser' => t('Create new user'), 'noimport' => t('Do not import')) + $backdrop_users;

    $form['usermap'] = array(
      '#title' => t('Users mapping'),
      '#type' => 'fieldset',
      '#description' => t('Map each Wordpress user to a distinct Drupal user. The number of posts for each Worpress user is indicated next to the usernames.'),
      '#collapsible' => FALSE,
      '#tree' => TRUE
    );

    foreach ($wordpress_import->usermap as $wp_user => $backdrop_user) {
      $form['usermap'][$wp_user] = array(
        '#type' => 'select',
        '#title' => $wp_user . ' (' . $wordpress_import->count['author_posts'][$wp_user] . ')',
        '#options' => $backdrop_users,
      );
    }
  }

  return $form;
}


/**
 * Validation for form step five.
 */
function wordpress_import_form_mapusers_validate(&$form, &$form_state) {

  if ($form_state['clicked_button']['#wizard type'] == 'cancel') {
    return;
  }

  // Make sure there is something to import
  if (count($form_state['values']['usermap']) > 0) {
    $i = FALSE;
    foreach ($form_state['values']['usermap'] as $wp_user => $backdrop_user) {
      if ($backdrop_user != 'noimport') {
        $i = TRUE;
        break;
      }
    }
    if (!$i) {
      form_set_error('usermap', t('Nothing to import!'));
    }
  }
  elseif (empty($form_state['values']['defaultuser'])) {
    form_set_error('defaultuser', t('Nothing to import!'));
  }
}


/**
 * Submit handler for form step five.
 */
function wordpress_import_form_mapusers_submit(&$form, &$form_state) {
  $wordpress_import = &$form_state['wordpress_import_obj'];

  if ($wordpress_import->options['usermap_type'] == 'default') {
    foreach ($wordpress_import->usermap as $key => $value) {
      $wordpress_import->usermap[$key] = $form_state['values']['defaultuser'];
    }
  }
  else {
    $wordpress_import->usermap = $form_state['values']['usermap'];
  }
}


/**
 * Form step six.
 * Form to create new user(s) if no mapping is wished.
 */
function wordpress_import_form_newusers($form, &$form_state) {
  $wordpress_import = &$form_state['wordpress_import_obj'];

  $form['newuser'] = array('#tree' => TRUE);

  if ($wordpress_import->options['usermap_type'] == 'default') {

    $form['newuser']['default'] = array('#type' => 'fieldset', '#title' => t('All Wordpress authors'));
    $form['newuser']['default']['name'] = array('#type' => 'textfield', '#title' => t('Username for new user'));
    $form['newuser']['default']['mail'] = array('#type' => 'textfield', '#title' => t('E-mail address for new user'));
    $form['newuser']['default']['password'] = array('#type' => 'textfield', '#title' => t('Password for new user'));
  }
  else {
    foreach ($wordpress_import->usermap as $key => $value) {
      if ($value == 'newuser') {
        $form['newuser'][$key] = array('#type' => 'fieldset', '#title' => t('Wordpress author %user', array('%user' => $key)));
        $form['newuser'][$key]['name'] = array('#type' => 'textfield', '#title' => t('Username for Wordpress author %user', array('%user' => $key)), '#default_value' => $key);
        $form['newuser'][$key]['mail'] = array('#type' => 'textfield', '#title' => t('E-mail address for Wordpress author %user', array('%user' => $key)));
        $form['newuser'][$key]['password'] = array('#type' => 'textfield', '#title' => t('Password for Wordpress author %user', array('%user' => $key)));
      }
    }
  }

  return $form;
}


/**
 * Validation for form step six.
 */
function wordpress_import_form_newusers_validate(&$form, &$form_state) {

  if ($form_state['clicked_button']['#wizard type'] == 'cancel') {
    return;
  }

  $new_user_names = array();
  $new_user_mails = array();
  foreach ($form_state['values']['newuser'] as $key => $value) {
    // Check usernames
    if ($error = user_validate_name($value['name'])) {
      form_set_error('newuser]['. $key .'][name', $error);
    }
    elseif (user_load_by_name($value['name'])) {
      form_set_error('newuser]['. $key .'][name', t('User !user already exists.', array('!user' => $value['name'])));
    }
    elseif (!empty($new_user_names) && in_array(strtolower($value['name']), $new_user_names)) {
      form_set_error('newuser]['. $key .'][name', t('Two users have the same name (!user).', array('!user' => $value['name'])));
    }

    // Check user emails
    if (!valid_email_address($value['mail'])) {
      form_set_error('newuser]['. $key .'][mail', 'Thhis is not a valid email adress.');
    }
    elseif (user_load_by_mail($value['mail'])) {
      form_set_error('newuser]['. $key .'][mail', t('User with mail !mail already exists.', array('!mail' => $value['mail'])));
    }
    elseif (!empty($new_user_mails) && in_array(strtolower($value['mail']), $new_user_mails)) {
      form_set_error('newuser]['. $key .'][mail', t('Two users have the same mail (!mail).', array('!mail' => $value['mail'])));
    }

    $new_user_names[] = strtolower($value['name']);
    $new_user_mails[] = strtolower($value['mail']);
  }
}


/**
 * Submit handler for form step six.
 */
function wordpress_import_form_newusers_submit(&$form, &$form_state) {
  $form_state['wordpress_import_obj']->newuser = $form_state['values']['newuser'];
}


/**
 * The finish form. Lst form step.
 */
function wordpress_import_form_ready($form, &$form_state) {
  $wordpress_import = &$form_state['wordpress_import_obj'];

  $form['informations'] = array(
   '#value' => t('Wordpress Import configuration is complete. Click "Finish" to launch the import process.'),
  );

  return $form;
}


/* ---------------- Form callback functions ---------------- */

/**
 * The callback function when the next button of a form step is clicked.
 *
 * @param  array &$form_state The stored values of the current form step.
 */
function wordpress_import_form_subtask_next(&$form_state) {
  $wordpress_import = &$form_state['wordpress_import_obj'];
  $cache = wordpress_import_form_set_page_cache($form_state['cache name'], $wordpress_import);
}


/**
 * The callback function when the cancel button of a form step is clicked.
 *
 * @param  array &$form_state The stored values of the current form step.
 */
function wordpress_import_form_subtask_cancel(&$form_state) {
  // ctools_object_cache_clear('wordpress_import', $form_state['cache name']);
  wordpress_import_form_clear_page_cache($form_state['cache name']);
  $form_state['redirect'] = 'admin/content/wordpress_import';
  backdrop_get_messages();
  backdrop_set_message('Import operation cancelled.');
}


/**
 * The callback function when the finish button of the last form step is clicked.
 *
 * @param  array &$form_state The stored values of the current form step.
 */
function wordpress_import_form_subtask_finish(&$form_state) {
  $wordpress_import = &$form_state['wordpress_import_obj'];
  wordpress_import_form_clear_page_cache($form_state['cache name']);

  // Prepare images directory
  if ($wordpress_import->options['images'] && !empty($wordpress_import->options['images_dir'])) {
    file_prepare_directory($wordpress_import->options['images_dir'], TRUE);
  }

  // Prepare batch operations
  $operations = array();
  $operations[] = array('wordpress_import_process_blog', array($wordpress_import));

  // Set up batch process
  $batch = array(
    'operations' => $operations,
    'finished' => 'wordpress_import_batch_finished',
    'title' => t('Wordpress import'),
    'init_message' => t('Wordpress import is starting processing'),
    'progress_message' => t('Processed @current out of @total.'),
    'error_message' => t('Wordpress import has encountered an error.'),
  );

  batch_set($batch);
  batch_process();

}

/**
 * Main batch import function.
 */
function wordpress_import_process_blog($wordpress_import, &$context) {

  // Initialize sandbox and results arrays to keep track of important import info
  if (empty($context['sandbox'])) {
    $context['sandbox']['vocab_done'] = FALSE;
    $context['sandbox']['users_done'] = FALSE;
    $context['sandbox']['format_done'] = FALSE;
    $context['sandbox']['progress'] = 0;
    $context['results']['created_users'] = 0;
    $context['results']['created_nodes'] = 0;
    $context['results']['created_terms'] = 0;
    $context['results']['created_categories'] = 0;
    $context['results']['downloaded_images'] = array();
    $context['results']['error_images'] = array();
    $context['results']['password_protected'] = 0;
    $context['results']['created_comments'] = 0;
    $context['results']['created_trackbacks'] = 0;
    $context['results']['created_items'] = array();

    // store usermapping in context, because it seems to get lost here
    $context['sandbox']['usermap'] = $wordpress_import->usermap;
  }

  // Create Drupal vocabularies for Wordpress categories and tags and populate them
  if (!$context['sandbox']['vocab_done'] && !$wordpress_import->options['disable_categories']) {
    wordpress_import_process_categories_tags($wordpress_import, $context);
    $context['sandbox']['vocab_done'] = TRUE;
  }

  // Create Drupal users as needed
  if (!$context['sandbox']['users_done']) {
      if ($wordpress_import->options['usermap_type'] == 'default' && !empty($wordpress_import->newuser['default'])) {

      // Create new default Drupal user and assign uid to each Wordpress author
      // check if a password is set
      $password = empty($wordpress_import->newuser['default']['password']) ? user_password() : $wordpress_import->newuser['default']['password'];

      $defaultuser = new User();
      $defaultuser->mail = $wordpress_import->newuser['default']['mail'];
      $defaultuser->pass = $password;
      $defaultuser->name = $wordpress_import->newuser['default']['name'];
      $defaultuser->status = 1;

      $defaultuser = user_save($defaultuser);
      $context['results']['created_users']++;

      // add user to created items for rollback
      $context['results']['created_items'][] = array('user' => $defaultuser->uid);

      foreach ($wordpress_import->usermap as $key => $value) {
        $context['sandbox']['usermap'][$key] = $defaultuser->uid;
      }

    }
    elseif ($wordpress_import->options['usermap_type'] == 'manual' && count($wordpress_import->newuser) >Â 0) {

      // Create new Drupal users as required and assign uid to corresponding Wordpress author
      foreach ($wordpress_import->newuser as $key => $value) {

        $password = empty($value['password']) ? user_password() : $value['password'];

        $user = new User();
        $user->mail = $value['mail'];
        $user->pass = $password;
        $user->name = $value['name'];
        $user->isNew = TRUE;
        $user->status = 1;

        user_save($user);

        // seems like we have to reload the user again
        $user = user_load_by_mail($value['mail']);

        $context['sandbox']['usermap'][$key] = $user->uid;
        $context['results']['created_users']++;

        // add user to created items for rollback
        $context['results']['created_items'][] = array('user' => $user->uid);
      }
    }
    $context['sandbox']['users_done'] = TRUE;
  }

  // Get or create content format as needed
  if (!$context['sandbox']['format_done']) {
    $wordpress_import->format = variable_get('wordpress_import_format_id', 0);
    if (!$wordpress_import->format || !filter_formats($wordpress_import->format)) {
      /*
      db_query("INSERT INTO {filter_formats} (name,cache) VALUES ('@s',1)", array('@s' => 'Wordpress format'));
      $wordpress_import->format = db_result(db_query("SELECT MAX(format) AS format FROM {filter_formats}"));
      db_query("INSERT INTO {filters} (format, module, delta, weight) VALUES (@d1, '@s', @d2, @d3)", array('@d1' => $wordpress_import->format, '@s' => 'filter', '@d2' => 2, '@d3' => 0));
      variable_set('wordpress_import_format_id', $wordpress_import->format);
      */
    }
    $context['sandbox']['format_done'] = TRUE;
  }

  // Initialize XML stream-based parsing
  $wordpress_import->reader = new XMLReader();
  $wordpress_import->reader->open($wordpress_import->filepath);

  // Limit number of posts imported per batch run
  $limit = 10;

  // Skip already imported posts
  $skip_imported = $context['sandbox']['progress'];

  while ($limit > 0 && $context['sandbox']['progress'] < $wordpress_import->count['posts']) {
    while ($wordpress_import->reader->read()) {
      if ($wordpress_import->reader->name == 'item' && $wordpress_import->reader->nodeType == XMLReader::ELEMENT) {
        if ($skip_imported > 0) {
          $wordpress_import->reader->next();
          $skip_imported--;
        }
        else {
          wordpress_import_process_post($wordpress_import, $context);
          $context['sandbox']['progress']++;
          $limit--;
          break;
        }
      }
    }
  }

  if ($context['sandbox']['progress'] < $wordpress_import->count['posts']) {
    $context['finished'] = $context['sandbox']['progress'] / ($wordpress_import->count['posts'] - 1);
  }

  $wordpress_import->reader->close();
}

/**
 * Import categories and tags as taxonomy terms
 */
function wordpress_import_process_categories_tags(&$wordpress_import, &$context) {

  if (!empty($wordpress_import->data['categories'])) {

    $wordpress_import->categories_vocabulary = $wordpress_import->options['nodetype_post_tm']['category_vocabulary'];
    $wordpress_import->categories_map = wordpress_import_get_terms($wordpress_import->options['nodetype_post_tm']['category_vocabulary']);

    foreach ($wordpress_import->data['categories'] as $category) {

      // Create term if it doesn't exist
      if (empty($wordpress_import->categories_map[$category['cat_name']])) {
        $term = new TaxonomyTerm();
        $term->name = $category['cat_name'];
        $term->description = $category['category_description'];
        $term->vocabulary = $wordpress_import->options['nodetype_post_tm']['category_vocabulary'];
        $term->parent = 0;

        if (!empty($category['category_parent']) && !empty($wordpress_import->categories_map[$category['category_parent']])) {
          $term->parent = $wordpress_import->categories_map[$category['category_parent']];
        }

        taxonomy_term_save($term);
        $context['results']['created_items'][] = array('taxonomy_term' => $term->tid);

        // we need to insert the parent to the table manually
        db_insert('taxonomy_term_hierarchy')
          ->fields(array(
            'tid' => $term->tid,
            'parent' => $term->parent,
            ))
          ->execute();

        $wordpress_import->categories_map[$category['cat_name']] = $term->tid;

        $context['results']['created_terms']++;
      }
    }
  }

  if (!empty($wordpress_import->data['tags'])) {

    $wordpress_import->tags_vocabulary = $wordpress_import->options['nodetype_post_tm']['tag_vocabulary'];
    $wordpress_import->tags_map = wordpress_import_get_terms($wordpress_import->options['nodetype_post_tm']['tag_vocabulary']);

    foreach ($wordpress_import->data['tags'] as $tag => $description) {

      // Create term if it doesn't exist
      if (empty($wordpress_import->tags_map[$tag])) {
        $term = new TaxonomyTerm();
        $term->name = $tag;
        $term->description = $description;
        $term->vocabulary = $wordpress_import->tags_vocabulary;
        $term->parent = 0;

        taxonomy_term_save($term);
        $context['results']['created_items'][] = array('taxonomy_term' => $term->tid);

        // we need to insert the parent to the table manually
        db_insert('taxonomy_term_hierarchy')
          ->fields(array(
            'tid' => $term->tid,
            'parent' => '0',
            ))
          ->execute();


        $wordpress_import->tags_map[$tag] = $term->tid;

        $context['results']['created_terms']++;
      }
    }
  }
}

/**
 * Process a Wordpress post
 */
function wordpress_import_process_post(&$wordpress_import, &$context) {

  $reader = $wordpress_import->reader;
  $context['sandbox']['node_duplicate'] = FALSE;
  $context['sandbox']['post'] = array('categories' => array(), 'tags' => array(), 'comments' => array());
  $context['sandbox']['downloaded_images'] = array();
  $context['sandbox']['error_images'] = array();

  $post = & $context['sandbox']['post'];

  while ($reader->read() && !($reader->name == 'item' && $reader->nodeType == XMLReader::END_ELEMENT)) {
    if ($reader->nodeType == XMLReader::ELEMENT) {
      switch ($reader->name) {
        case 'title' :
          $reader->read();
          $post['title'] = $reader->value;
          break;
        case 'dc:creator' :
          $reader->read();
          $post['author'] = $reader->value;
          break;
        case 'wp:post_date' :
          $reader->read();
          $post['date'] = $reader->value;
          break;
        case 'wp:post_type' :
          $reader->read();
          $post['type'] = $reader->value;
          break;
        case 'wp:status' :
          $reader->read();
          $post['status'] = $reader->value;
          break;
        case 'wp:is_sticky' :
          $reader->read();
          $post['is_sticky'] = $reader->value;
          break;
        case 'wp:post_password' :
          $reader->read();
          $post['post_password'] = $reader->value;
          break;
        case 'content:encoded' :
          $reader->read();
          $post['content'] = $reader->value;
          break;
        case 'excerpt:encoded' :
          $reader->read();
          $post['excerpt'] = $reader->value;
          break;
        case 'link' :
          $reader->read();
          $post['link'] = $reader->value;
          break;
        case 'wp:comment_status' :
          $reader->read();
          $post['comment_status'] = $reader->value;
          break;
        case 'category' :
          if (!$wordpress_import->options['disable_categories']) {
            if ($reader->getAttribute('domain') == 'category') {
              $reader->read();
              $post['categories'][] = $reader->value;
            }
            elseif ($reader->getAttribute('domain') == 'post_tag') {
              $reader->read();
              $post['tags'][] = $reader->value;
            }
          }
          break;
        case 'wp:comment' :
          if (!$wordpress_import->options['disable_comments']) {
            $comment = array();
            while ($reader->read() && !($reader->name == 'wp:comment' && $reader->nodeType == XMLReader::END_ELEMENT)) {
              if ($reader->nodeType == XMLReader::ELEMENT) {
                $nodename = str_replace('wp:comment_', '', $reader->name);
                $reader->read();
                $comment[$nodename] = $reader->value;
              }
            }
            if (!empty($comment)) {
              $post['comments'][] = $comment;
            }
          }
          break;

        // get the translations as stored by Stella plugin
        case 'wp:postmeta':
          $reader->read();
          $reader->read();
          if ($reader->name == 'wp:meta_key') {
            $reader->read();
            if (strpos($reader->value, '_title') !== FALSE) {
              // find the language
              $components = explode('-', $reader->value);
              if (isset($components[1])) {
                $reader->read();
                $reader->read();
                $reader->read();
                $reader->read();
                $post['translations'][$components[1]]['title'] = $reader->value;
              }
            }
            if (strpos($reader->value, '_body') !== FALSE) {
              // find the language
              $components = explode('-', $reader->value);
              if (isset($components[1])) {
                $reader->read();
                $reader->read();
                $reader->read();
                $reader->read();
                $post['translations'][$components[1]]['body'] = $reader->value;
              }
            }

          }
          break;
      }
    }
  }

  // Node object setup ---------------------- //
  // $node = new Node();
  $node = array();
  $node_og = FALSE;

  // Node type
  switch ($post['type']) {
    case 'post' :
      $node['type'] = $wordpress_import->options['nodetype_post'];
      $node_og = $wordpress_import->options['nodetype_post_og'];
      break;
    case 'page' :
      $node['type'] = $wordpress_import->options['nodetype_page'];
      $node_og = $wordpress_import->options['nodetype_page_og'];
      break;
    default :
      return;
  }

  $node = entity_create('node', $node);

  // Catch noimport content type flag
  if ($node->type == 'noimport') {
    return;
  }
dpm($context['sandbox']['usermap'][$post['author']]);
  // Node uid (return if we don't want this author)
  $node->uid = $context['sandbox']['usermap'][$post['author']];
  if ($node->uid == 'noimport' || !ctype_digit($node->uid)) {
    return;
  }

  // Node title
  if (!empty($post['title'])) {
    $node->title = html_entity_decode($post['title'], ENT_COMPAT, 'UTF-8');
  }
  else {
    $node->title = t('Untitled');
  }

  // we need the language here
  $node_language = (isset($wordpress_import->options['language']) ? $wordpress_import->options['language'] : LANGUAGE_NONE);

  $node->langcode = $node_language;

  $format = ($post['type'] == 'post') ? $wordpress_import->options['nodetype_post_format'] : $wordpress_import->options['nodetype_page_format'];

  // Process images for this post and replace URLs
  if ($wordpress_import->options['images']) {
    wordpress_import_process_post_images($post['content'], $wordpress_import->options['images_dir'], $context);
  }

  // Node content
  $node->body[LANGUAGE_NONE][0]['value'] = str_replace('<!--more-->', '<!--break-->', $post['content']);
  $node->body[LANGUAGE_NONE][0]['format'] =  $format;
  if (!empty($post['excerpt'])) {
    $node->body[LANGUAGE_NONE][0]['summary'] = $post['excerpt'];
  }

  // Node language
  $node->language = $node_language;

  // Node timestamp
  $node->created = strtotime($post['date']);
  $node->changed = $node->created;

  // Node status
  switch ($post['status']) {
    case 'publish':
      if (empty($post['post_password'])) {
        $node->status = 1;
      }
      else {
        $node->status = 0;
        $context['results']['password_protected']++;
      }
      break;
    default:
      $node->status = 0;
  }

  // Node promote
  switch ($post['is_sticky']) {
    case '1':
      $node->promote = 1;
      break;
    default:
      $node->promote = 0;
  }

  // Node comment status
  $node->comment = $post['comment_status']=='open'? '2' : '0' ;

  // Check if node wasn't already imported
  $temp_node = NULL;
  $node_exist = wordpress_import_has_node_duplicate($node);
  if ($node_exist) {
    // load the node and add the comments
    $temp_node = node_load($node_exist);
    if (module_exists('comment') && !empty($post['comments'])) {
      wordpress_import_process_post_comments($post['comments'], $temp_node->nid, $wordpress_import, $context);
    }
    node_save($temp_node);
    return;
  }

  $node_path = wordpress_import_process_post_link($post['link'], $wordpress_import->data['baseurl']);

  // Process link for this post
  if (module_exists('path') && $wordpress_import->options['aliases']) {
    // switch to drupal 7 / backdrop path
    $path = array (
      'alias' => $node_path,
      'langcode' => $node->language,
      'auto' => FALSE,
    );

    $node->path = $path;
  }

  if (module_exists('taxonomy')) {
    // @todo: find out, why categories_map and tags_map dissapear from $wordpress_import
    if ($node->type == $wordpress_import->options['nodetype_post']) {
      if ($wordpress_import->options['nodetype_post_tm']['category_fieldname'] != 'noimport') {
        // get the category term id and add it to the node
        if (!empty($post['categories'])) {
          foreach ($post['categories'] as $key => $value) {
            $tid = wordpress_import_get_term_id($value, $wordpress_import->options['nodetype_post_tm']['category_vocabulary']);
            if ($tid) {
              $field_name = $wordpress_import->options['nodetype_post_tm']['category_fieldname'];
              $field = $node->{$field_name};
              // $field[LANGUAGE_NONE][]['tid'] = $wordpress_import->categories_map[$value];
              $field[LANGUAGE_NONE][]['tid'] = $tid;
              $node->$field_name = $field;
            }
          }
        }
      }
      if ($wordpress_import->options['nodetype_post_tm']['tag_fieldname'] != 'noimport') {
        if (!empty($post['tags'])) {
          foreach ($post['tags'] as $key => $value) {
            $tid = wordpress_import_get_term_id($value, $wordpress_import->options['nodetype_post_tm']['tag_vocabulary']);
            if ($tid) {
              $field_name = $wordpress_import->options['nodetype_post_tm']['tag_fieldname'];
              $field = $node->{$field_name};
              // $field[LANGUAGE_NONE][]['tid'] = $wordpress_import->tags_map[$value];
              $field[LANGUAGE_NONE][]['tid'] = $tid;
              $node->$field_name = $field;
            }
          }
        }
      }
    }
  }

  // Save the node
  $result = node_save($node);
  $context['results']['created_items'][] = array('node' => $node->nid);

  // Process comments and trackbacks for this post
  if (module_exists('comment') && !empty($post['comments'])) {
    wordpress_import_process_post_comments($post['comments'], $node->nid, $wordpress_import, $context);
  }

  // create the translated nodes
  if (isset($post['translations'])) {

    if ($temp_node != NULL) {
      // node already exists, so switch
      $node = $temp_node;
    }

    foreach ($post['translations'] as $key => $value) {
      // Process images for this post and replace URLs
      if ($wordpress_import->options['images']) {
        wordpress_import_process_post_images($value['body'], $wordpress_import->options['images_dir'], $context);
      }

      $tn = new Node();
      $tn->type = $node->type;
      $tn->langcode = $key;
      $tn->title = $value['title'];
      $tn->uid = $node->uid;
      $tn->status = $node->status;
      $tn->created = $node->created;
      $tn->body[LANGUAGE_NONE][0]['value'] = str_replace('<!--more-->', '<!--break-->', $value['body']);
      $tn->body[LANGUAGE_NONE][0]['format'] = $format;
      $tn->comment = $node->comment;
      $tn->promote = $node->promote;
      $tn->sticky = $node->sticky;
      $tn->tnid = $node->nid;
      if (!$wordpress_import->options['redirect']  && $wordpress_import->options['aliases']) {
        $tn->path['alias'] = $node->path['alias'];
        $tn->path['auto'] = FALSE;
      }
      $tn->path['langcode'] = $key;
      if (isset($node->field_category)) {
        $tn->field_category = $node->field_category;
      }
      if (isset($node->field_tags)) {
        $tn->field_tags = $node->field_tags;
      }

      if (wordpress_import_has_node_duplicate($tn) === FALSE) {
        node_save($tn);
        $context['results']['created_nodes']++;
        $context['results']['created_items'][] = array('node' => $tn->nid);

        // Create redirect for the translated node
        if (module_exists('redirect') && $wordpress_import->options['redirect']) {
          wordpress_import_create_redirect($tn, $node_path, $context);
        }

        // create menu link if $node type is page and selected
        if ($wordpress_import->options['create_menu_items_page']
            && $tn->type == $wordpress_import->options['nodetype_page']) {
          // here we have translated nodes, so use language in options
          $options = array();
          $language_list = language_list('enabled');
          if (isset($language_list[$tn->langcode])) {
            $options['language'] = $language_list[$tn->langcode];
          }
          wordpress_import_create_menu_link($tn, $wordpress_import->options['create_menu_items_page_menu'], $context, FALSE, $options);
        }

        // we need to set the tnid of the original node, too
        if ($node->tnid != $node->nid) {
          $node->tnid = $node->nid;
          node_save($node);
        }
      }
    }
  }

  // Node OG parameters
  if (module_exists('og') && $node_og) {
    $node->og_groups = $wordpress_import->og_groups;
    $node->og_public = (int) $wordpress_import->og_public;
    og_save_ancestry($node);
  }


  // Create redirect for this node
  if (module_exists('redirect') && $wordpress_import->options['redirect']) {
    wordpress_import_create_redirect($node, $node_path, $context);

    // also create a redirect with no language
    wordpress_import_create_redirect($node, $node_path, $context, FALSE);
  }

  // create menu link if $node type is page and selected
  if ($wordpress_import->options['create_menu_items_page']
      && $node->type == $wordpress_import->options['nodetype_page']) {
    $options = array();
    if ($node->langcode != LANGUAGE_NONE) {
      $language_list = language_list('enabled');
      if (isset($language_list[$node->langcode])) {
        $options['language'] = $language_list[$node->langcode];
      }
    }
    wordpress_import_create_menu_link($node, $wordpress_import->options['create_menu_items_page_menu'], $context, FALSE, $options);
  }


  // Update messages infos with nid
  if (!empty($context['sandbox']['downloaded_images']) || !empty($context['sandbox']['error_images'])) {
    foreach ($context['sandbox']['downloaded_images'] as $a) {
      $a['nid'] = $node->nid;
      $context['results']['downloaded_images'][] = $a;
    }
    foreach ($context['sandbox']['error_images'] as $a) {
      $a['nid'] = $node->nid;
      $a['title'] = $node->title;
      $context['results']['error_images'][] = $a;
    }
  }

  // Update the context
  $context['results']['created_nodes']++;
  $context['message'] = t('Import in progress : @created - @title', array('@created' => format_date($node->created, 'small'), '@title' => $node->title));

  unset($context['sandbox']['post']);
  unset($context['sandbox']['downloaded_images']);
  unset($context['sandbox']['error_images']);

  // store the new generated items to the tempstore
  // and make it valid for three days
  wordpress_import_db_set($wordpress_import->import_id , $context['results']['created_items']);
}


/**
 * Process post link into node path
 */
function wordpress_import_process_post_link($link, $baseurl) {

  $path = $link;
  $path = substr($path, strlen($baseurl));
  $path = rtrim($path, '/');

  // Check for Wordpress ugly permalinks and replace with proper Drupal-style aliases
  if (preg_match('/\?p=(\d+)/', $path, $id)) {
    $path = 'p/' . $id[1];
  }
  elseif (preg_match('/\?page_id=(\d+)/', $path, $id)) {
    $path = 'page_id/' . $id[1];
  }

  return $path;
}


/**
 * Process comments and trackbacks for this post
 */
function wordpress_import_process_post_comments($comments, $nid, $wordpress_import, &$context) {

  $node_duplicate = $context['sandbox']['node_duplicate'];

  $node_trackbacks = array();
  $node_comments = array();
  $comment_id = 0;

  foreach ($comments as $comment) {

    switch ($comment['approved']) {
      case '0':
        $status = COMMENT_NOT_PUBLISHED;
        break;
      case '1':
        $status = COMMENT_PUBLISHED;
        break;
      case 'spam':
        continue 2;
    }

    switch ($comment['type']) {
      case 'trackback':
        if (module_exists('trackback') && !$wordpress_import->options['disable_trackbacks']) {
          $node_trackback = array(
            'nid' => $nid,
            'created' => strtotime($comment['date']),
            'changed' => strtotime($comment['date']),
            'site' => $comment['author_IP'],
            'name' => decode_entities(strip_tags($comment['author'])),
            'subject' => trim(truncate_utf8(decode_entities(strip_tags($comment['content'])), 29, TRUE)),
            'url' => $comment['author_url'],
            'excerpt' => $comment['content'],
            'status' => 1
            );
          // Check if duplicate
          if ($node_duplicate) {
            $tr = db_query("SELECT tr.trid FROM {trackback_received} tr WHERE tr.nid = %d AND tr.created = %d", $node_duplicate->nid, $node_trackback['created']);
            if ($tr->trid && $tr->excerpt == $node_trackback['excerpt']) {
              continue 2;
            }
            else {
              $node_trackbacks[$node_trackback['created']] = $node_trackback;
            }
          }
        }
        break;
      default:
        $nc = array(
          'nid' => $nid,
          'pid' => 0,
          'subject' => trim(truncate_utf8(decode_entities(strip_tags($comment['content'])), 29, TRUE)),
          'name' => decode_entities(strip_tags(substr($comment['author'], 0, 60))),
          'mail' => $comment['author_email'],
          'homepage' => $comment['author_url'],
          'created' => strtotime($comment['date']),
          'changed' => strtotime($comment['date']),
          'hostname' => $comment['author_IP'],
          'status' => $status,
          'format' => $wordpress_import->options['comments_format'],
        );

        $node_comment = entity_create('comment', $nc);
        $node_comment->comment_body[LANGUAGE_NONE][0]['value'] = $comment['content'];
        $node_comment->comment_body[LANGUAGE_NONE][0]['format'] = $wordpress_import->options['comments_format'];

        // Check if duplicate
        if ($node_duplicate) {
          $c = db_query("SELECT c.cid, c.comment FROM {comments} c WHERE c.nid = %d AND c.timestamp = %d", $node_duplicate->nid, $node_comment['timestamp']);
          if ($c->cid && $c->comment == $node_comment['comment_body']) {
            continue 2;
          }
        }
        else {
          $node_comments[$node_comment->created] = $node_comment;
        }
        break;
    }
  }

  // Sort comments by timestamp so the thread won't be messed up in Drupal
  ksort($node_trackbacks);
  ksort($node_comments);

  // Save trackbacks
  foreach ($node_trackbacks as $node_trackback) {
    db_query("INSERT INTO {trackback_received} (nid, created, site, name, subject, url, excerpt, status) VALUES (%d, %d, '%s', '%s', '%s', '%s', '%s', %d)",
      $node_trackback['nid'],
      $node_trackback['created'],
      $node_trackback['site'],
      $node_trackback['name'],
      $node_trackback['subject'],
      $node_trackback['url'],
      $node_trackback['excerpt'],
      $node_trackback['status']
      );
    $context['results']['created_trackbacks']++;
  }

  // Save comments
  foreach ($node_comments as $node_comment) {
    $comment_id = comment_save($node_comment);
    if ($comment_id) {
      $context['results']['created_items'][] = array('comment' => $comment_id);
    }
    // Update fields that haven't been set by comment_save
    db_query("UPDATE {comment} SET hostname= '@hn', created= @ts, status= @st WHERE cid= @id", array(
      '@hn' => $node_comment->hostname,
      '@ts' => $node_comment->timestamp,
      '@st' => $node_comment->status,
      '@id' => $comment_id
      )
      );
    $context['results']['created_comments']++;
  }
}

/**
 * Process node body and download image content
 */
function wordpress_import_process_post_images(&$body, $images_dir, $context) {
  global $base_path;

  // Find image URL in content
  preg_match_all('/(img|src)=("|\')[^"\'>]+/i', $body, $media);
  $imgdata = preg_replace('/(img|src)("|\'|="|=\')(.*)/i', "$3", $media[0]);

  foreach ($imgdata as $imgurl) {
    $urlinfo = parse_url($imgurl);
    $imginfo = pathinfo($urlinfo['path']);
    if (($urlinfo['scheme'] == 'http' || $urlinfo['scheme'] == 'https') && isset($imginfo['extension'])) {
      if ((strcasecmp($imginfo['extension'], 'jpg') == 0) ||
        (strcasecmp($imginfo['extension'], 'jpeg') == 0) ||
        (strcasecmp($imginfo['extension'], 'gif') == 0) ||
        (strcasecmp($imginfo['extension'], 'png') == 0)) {

        $ch = curl_init($imgurl);

        // Check if cURL object OK
        if (!$ch) {
          $context['sandbox']['error_images'][] = array('oldurl' => $imgurl);
          continue;
        }

        // Check if image was already downloaded
        foreach ($context['results']['downloaded_images'] as $img) {
          if ($img['imgurl'] == $imgurl) {
            $body = str_replace($imgurl, $img['newurl'], $body);
            continue 2;
          }
        }

        curl_setopt($ch, CURLOPT_TIMEOUT, 10);

        // Obtain new URL in case of redirections
        $imgnewurl = wordpress_import_curl_redir_url($ch);
        curl_close($ch);

        if ($imgnewurl) {

          // Download image if it not exists
          $new_file_name = $images_dir . '/' . $imginfo['basename'];
          if (!file_exists($new_file_name)) {
            $imgfile = file_create_filename(urldecode($imginfo['basename']), $images_dir);
            $imgout = fopen($imgfile, 'wb');
            $ch = curl_init($imgnewurl);
            curl_setopt($ch, CURLOPT_HEADER, FALSE);
            curl_setopt($ch, CURLOPT_TIMEOUT, 10);
            curl_setopt($ch, CURLOPT_FILE, $imgout);
            curl_exec($ch);
            curl_close($ch);
            fclose($imgout);
          }

          $rel_dir = str_replace('.', '', $images_dir);

          $newurl = /* $base_path . */ $rel_dir . '/' . $imginfo['basename'];

          // Replace image URL with new path in post
          $body = str_replace($imgurl, $newurl, $body);
          $context['sandbox']['downloaded_images'][] = array('oldurl' => $imgurl, 'newurl' => $newurl, 'file' => $imgfile);
        }
        else {
          $context['sandbox']['error_images'][] = array('oldurl' => $imgurl);
        }
      }
    }
  }
}


/**
 * Batch wrap-up function, displays import process results
 */
function wordpress_import_batch_finished($success, $results, $operations) {

  if ($success) {

    $message = t('Import successful : ');

    $msg_results = array();
    $msg_results[] = '<li>' . t('@created_nodes nodes', array('@created_nodes' => $results['created_nodes'])) . '</li>';
    $msg_results[] = '<li>' . t('@created_users users', array('@created_users' => $results['created_users'])) . '</li>';
    $msg_results[] = '<li>' . t('@created_terms taxonomy terms', array('@created_terms' => $results['created_terms'])) . '</li>';
    $msg_results[] = '<li>' . t('@created_comments comments', array('@created_comments' => $results['created_comments'])) . '</li>';
    $msg_results[] = '<li>' . t('@created_trackbacks trackbacks', array('@created_trackbacks' => $results['created_trackbacks'])) . '</li>';
    $msg_results[] = '<li>' . t('@downloaded_images/@total_images images', array('@downloaded_images' => count($results['downloaded_images']), '@total_images' => count($results['downloaded_images'])+count($results['error_images']))) . '</li>';

    backdrop_set_message($message . '<ul>' . join("\n", $msg_results) . '</ul>');

    if (function_exists('dpm')) {
      // dpm($results['error_images']);
    }

    if (count($results['error_images']) > 0) {

      $errors = '';
      foreach ($results['error_images'] as $error_image) {
        $errors .= '<li>' . l($error_image['title'], 'node/' . $error_image['nid']) . "</li>\n";
      }
      backdrop_set_message(t('Some images could not be transferred for these nodes :') . '<ul>' . $errors . '</ul>', 'warning');
    }

    if ($results['password_protected'] > 0) {
      backdrop_set_message(t('Encountered @password_protected password-protected posts. These were imported as unpublished nodes.', array('@password_protected' => $results['password_protected'])), 'warning');
    }

  }
  else {

    backdrop_set_message(t('Import failed.'), 'error');

  }

}


/* ---------------- Import utility functions ---------------- */

/**
 * Open WXR file in XMLReader and extract relevant data prior to import.
 */
function wordpress_import_read_wxr(&$wordpress_import) {

  $is_wxr_file = FALSE;
  $is_valid_xml = FALSE;

  $wordpress_import->data['categories'] = array();
  $wordpress_import->data['tags'] = array();
  $wordpress_import->usermap = array();
  $wordpress_import->count['posts'] = 0;
  $wordpress_import->count['author_posts'] = array();
  $wordpress_import->count['comments'] = 0;
  $wordpress_import->count['categories'] = 0;
  $wordpress_import->count['tags'] = 0;

  $reader = new XMLReader();
  $reader->open($wordpress_import->filepath);

  while ($reader->read()) {

    if ($reader->nodeType == XMLReader::ELEMENT) {

      // Check for WXR XML marker
      // TODO: document why extra validation can't be performed, THERE IS NO DTD FOR WXR!
      if ($reader->name == 'rss') {
        $is_wxr_file = $reader->moveToAttribute('xmlns:wp');
      }

      if ($reader->name == 'wp:base_blog_url') {
        $reader->read();
        $wordpress_import->data['baseurl'] = $reader->value;
        if (substr($wordpress_import->data['baseurl'], -1) != '/') {
          $wordpress_import->data['baseurl'] .= '/';
        }
      }

      // Read posts data
      if ($reader->name == 'item') {
        $reader->read();
        $wordpress_import->count['posts']++;
      }

      // Read categories data
      if ($reader->name == 'wp:category') {
        $domCategory = $reader->expand();
        $wordpress_import->data['categories'][] = array();
        foreach ($domCategory->childNodes as $node) {
          $wordpress_import->data['categories'][key($wordpress_import->data['categories'])][substr($node->nodeName, 3)] = $node->nodeValue;
        }
        next($wordpress_import->data['categories']);
        $wordpress_import->count['categories']++;
      }

      // Read tags data
      if ($reader->name == 'wp:tag_name') {
        $reader->read();
        $tag_name = $reader->value;
        $wordpress_import->data['tags'][$tag_name] = '';
        while ($reader->read() && !($reader->name == 'wp:tag' && $reader->nodeType == XMLReader::END_ELEMENT)) {
            if ($reader->name == 'wp:tag_description' && $reader->nodeType == XMLReader::ELEMENT) {
                $reader->read();
                $wordpress_import->data['tags'][$tag_name] = $reader->value;
            }
        }
        $wordpress_import->count['tags']++;
      }

      // Read users data, create user map array
      if ($reader->name == 'dc:creator') {
        $reader->read();
        $wordpress_import->usermap[$reader->value] = 0;
        $wordpress_import->count['author_posts'][$reader->value]++;
      }

      // Count comments
      if ($reader->name == 'wp:comment') {
        $wordpress_import->count['comments']++;
      }
    }
    elseif ($reader->name == 'rss' && $reader->nodeType == XMLReader::END_ELEMENT) {
      // Reached the end of the document, we can safely assume valid XML
      $is_valid_xml = TRUE;
    }
  }

  $reader->close();

  return $is_wxr_file && $is_valid_xml;
}


/**
 * Return an array of taxonomy terms belonging to a vocabulary
 */
function wordpress_import_get_terms($vid) {
  $db_result = db_query('SELECT t.tid, t.name FROM {taxonomy_term_data} t WHERE t.vocabulary = :vid', array(':vid' => $vid))->fetchAll();

  $result = array();
  foreach ($db_result as $term) {
    $result[$term->name] = $term->tid;
  }

  return $result;
}


/**
 * Create a redirect for a node
 * @param  object  $node      The node object.
 * @param  string  $path      The redirect path.
 * @param  array   &$context  the batch context array.
 * @param  boolean $with_lang Indicator if the redirect has a language context.
 */
function wordpress_import_create_redirect($node, $path, &$context, $with_lang = TRUE) {
  $redirect = new Redirect();
  if ($with_lang) {
    $redirect->langcode = $node->langcode;
  }
  else {
    $redirect->langcode = LANGUAGE_NONE;
  }

  $redirect->source = $path;
  $redirect->redirect = 'node/' . $node->nid;;

  $result = redirect_save($redirect);
  if (($result == SAVED_NEW) || ($result == SAVED_UPDATED)) {
    $context['results']['created_items'][] = array('redirect' => $redirect->rid);
  }
}


/**
 * Create a menu link for a node.
 * @param  object  $node      The node bject.
 * @param  string  $menu_name The menu name the link is stored to.
 * @param  array   &$context  The batch context array.
 * @param  boolean $expanded  Not use. Menu expanded yes/no.
 * @param  array   $options   An array with options e.g. the language for the menu link.
 */
function wordpress_import_create_menu_link($node, $menu_name, &$context, $expanded = FALSE, $options = array()) {
  $item = array(
    'link_path' => 'node/' . $node->nid,
    'link_title' => empty($node->title) ? 'Untitled' : $node->title,
    'menu_name' => $menu_name,
    // 'expanded' => $expanded,
    'options' => $options,
  );
  $mid = menu_link_save($item);
  if ($mid) {
    $context['results']['created_items'][] = array('menu_link' => $mid);
  }
}


/**
 * The form for the rollback.
 */
function wordpress_rollback_form($form, &$form_state) {

  $result = db_select('wordpress_import', 'w')
                    ->fields('w', array('iid', 'identifier'))
                    ->execute();

  $options = array();
  while($record = $result->fetchAssoc()) {
    $options[$record['iid']] = $record['identifier'];
  }

  $form['rollback_select'] = array(
    '#type' => 'radios',
    '#options' => $options,
    '#title' => t('Select the import you want to roll back.'),
  );
  $form['rollback_submit'] = array(
    '#type' => 'submit',
    '#value' => 'Rollback',
  );
  return $form;
}


/**
 * Submit handler for the rollback form.
 */
function wordpress_rollback_form_submit($form, &$form_state) {
  $selected_rollback = $form_state['values']['rollback_select'];

  if (!empty($selected_rollback)) {
    wordpress_import_rollback($selected_rollback);
  }
  else {
    backdrop_set_message('Please select a rollback', 'warning');
  }
}


/**
 * The edit form for rollbacks.
 */
function wordpress_rollback_edit_form($form, &$form_state) {

  $result = db_select('wordpress_import', 'w')
                    ->fields('w', array('iid', 'identifier'))
                    ->execute();

  $options = array();
  while($record = $result->fetchAssoc()) {
    $options[$record['iid']] = $record['identifier'];
  }

  $form['rollback_delete_select'] = array(
    '#type' => 'checkboxes',
    '#options' => $options,
    '#title' => t('Select the import you want to delete.'),
  );
  $form['rollback_submit'] = array(
    '#type' => 'submit',
    '#value' => 'Delete',
  );

  return $form;
}


/**
 * Submit handler for the rollback edit form.
 */
function wordpress_rollback_edit_form_submit($form, &$form_state) {
  $selected_rollback = $form_state['values']['rollback_delete_select'];

  $ids = array();
  foreach ($selected_rollback as $key => $value) {
    if ($value != 0) {
      $ids[] = $key;
    }
  }

  if (!empty($ids)) {
    wordpress_import_db_clear($ids);
  }
  else {
    backdrop_set_message('Please select a rollback', 'warning');
  }
}


/**
 * Process the rollback of the import in a batch.
 */
function wordpress_import_rollback($rollback_id) {

  $created_items = wordpress_import_db_get($rollback_id);
  if (empty($created_items)) {
    return;
  }

  // setup the batch
  $operations = array();
  $counter++;
  foreach ($created_items as $key => $value) {
    $item_type = key($value);
    $item_id = $value[$item_type];

    $operations[] = array(
      'wordpress_import_rollback_callback',
      array(
        $item_type,
        $item_id,
      ),
    );
  }

  $batch = array(
    'operations' => $operations,
    'finished' => 'wordpress_import_rollback_finished',
    'title' => t('Wordpress import'),
    'init_message' => t('Wordpress import rollback is starting processing'),
    'progress_message' => t('Processed @current out of @total.'),
    'error_message' => t('Wordpress import has encountered an error.'),
  );
  batch_set($batch);
  batch_process('/admin/content/wordpress_import');
}


/**
 * Tha callback form for the rollback batch.
 * @param  string $item_type The item type to be deleted.
 * @param  string $item_id   The corresponding item id.
 * @param  array  &$context  The batch context array.
 */
function wordpress_import_rollback_callback($item_type, $item_id, &$context) {

  $function = $item_type . '_delete';
  if(function_exists($function)) {
    $function($item_id);
  }
}


/**
 * The finish callback for the rollback batch.
 */
function wordpress_import_rollback_finished($success, $results, $operations) {
  if ($success) {
    backdrop_set_message('Rollback successful');
  }
}


/**
 * cURL helper function since PHP has disabled redirection support.
 * Taken from http://www.php.net/manual/en/function.curl-setopt.php#71313
 */
function wordpress_import_curl_redir_url($ch) {
    static $curl_loops = 0;
    static $curl_max_loops = 20;
    if ($curl_loops++ >= $curl_max_loops) {
        $curl_loops = 0;
        return FALSE;
    }
    curl_setopt($ch, CURLOPT_HEADER, TRUE);
    curl_setopt($ch, CURLOPT_RETURNTRANSFER, TRUE);
    curl_setopt($ch, CURLOPT_NOBODY, TRUE);
    $header = curl_exec($ch);
    $http_code = curl_getinfo($ch, CURLINFO_HTTP_CODE);
    if ($http_code == 301 || $http_code == 302) {
        $matches = array();
        preg_match('/Location:(.*?)\n/', $header, $matches);
        $url = @parse_url(trim(array_pop($matches)));
        if (!$url) {
            //couldn't process the url to redirect to
            $curl_loops = 0;
            return FALSE;
        }
        $last_url = parse_url(curl_getinfo($ch, CURLINFO_EFFECTIVE_URL));
        if (!$url['scheme'])
            $url['scheme'] = $last_url['scheme'];
        if (!$url['host'])
            $url['host'] = $last_url['host'];
        if (!$url['path'])
            $url['path'] = $last_url['path'];
        $new_url = $url['scheme'] . '://' . $url['host'] . $url['path'] . ($url['query'] ? '?' . $url['query'] : '');
        curl_setopt($ch, CURLOPT_URL, $new_url);
        //debug('Redirecting to', $new_url);
        return wordpress_import_curl_redir_url($ch);
    }
    elseif ($http_code == 200) {
      $curl_loops = 0;
      return curl_getinfo($ch, CURLINFO_EFFECTIVE_URL);
    }
    else {
      $curl_loops = 0;
      return FALSE;
    }
}


/**
 * [wordpress_import_file_directory_path description]
 * @return string The public file path.
 */
function wordpress_import_file_directory_path() {
  return variable_get('file_public_path', conf_path() . '/files');
}


/**
 * Helper function to find duplicate nodes
 *
 * @param node $node the node to search for
 *
 * @return mixed FALSE if node is not found, nid otherwise.
 */
function wordpress_import_has_node_duplicate($node) {
  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'node');
  $query->propertyCondition('title', $node->title, '=');
  $query->propertyCondition('created', $node->created, '=');
  $query->propertyCondition('type', $node->type, '=');
  $query->propertyCondition('langcode', $node->langcode, '=');

  $ids = $query->execute();

  if (isset($ids['node'])) {
    $ids = array_keys($ids['node']);
    $id = array_shift($ids);
    return $id;
  }

  return FALSE;
}


/**
 * Helper function to find term id for a name
 *
 * @param string $$name the node to search for
 *
 * @return mixed FALSE if name is not found, tid otherwise.
 */
function wordpress_import_get_term_id($name, $vid) {
  $result = db_query('SELECT t.tid FROM {taxonomy_term_data} t WHERE t.name = :name AND t.vocabulary = :vocab', array(':name' => $name, ':vocab' => $vid))->fetchAll();

  return empty($result) ? FALSE : $result[0]->tid;
}


function wordpress_import_db_create($identifier) {
  $iid = db_insert('wordpress_import')
    ->fields(array(
      'identifier' => $identifier,
      'value' => serialize(array()),
    ))
    ->execute();

    return $iid;
}


/**
 * Helper function to store rollback information
 * @param  string $id    The import id.
 * @param  array  $value The value to be stored.
 */
function wordpress_import_db_set($id, $value) {
  db_update('wordpress_import')
    ->fields(array('value' => serialize($value)))
    ->condition('iid', $id)
    ->execute();
}

/**
 * Helper function to get a stored rollback.
 * @param  string $id The import id.
 * @return array      An array with the imported items.
 */
function wordpress_import_db_get($id) {
  $data = db_query('SELECT * FROM {wordpress_import} WHERE iid = :id', array(':id' => $id))->fetchObject();
  if ($data) {
    $data = unserialize($data->value);
  }
  return $data;
}

/**
 * Helper function to clear a stored rollback
 * @param  string $id The import id.
 */
function wordpress_import_db_clear($id) {
  db_delete('wordpress_import')
    ->condition('iid', ($id), 'IN')
    ->execute();
}
