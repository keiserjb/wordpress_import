<?php

/**
 * @file
 * WordPress Import module.
 *
 * This module allows importing a blog from a WXR file generated by WordPress.
 */

/**
 * Implementation of hook_menu()
 */
function wordpress_import_menu() {
  $items = array();

  $items['admin/content/wordpress_import'] = array(
    'title' => 'WordPress import',
    'description' => 'Import WordPress WXR file',
    'page callback' => 'wordpress_import_home',
    'access arguments' => array('import wordpress blog'),
    );
  $items['admin/content/wordpress_import/rollback'] = array(
    'title' => 'WordPress import rollback',
    'type' => MENU_LOCAL_TASK,
    'description' => 'Rollback last WordPress Import',
    'page callback' => 'backdrop_get_form',
    'page arguments' => array('wordpress_rollback_form'),
    'access arguments' => array('import wordpress blog'),
    'weight' => 1,
    );
  $items['admin/content/wordpress_import/rollback_edit'] = array(
    'title' => 'WordPress import edit rollbacks',
    'type' => MENU_LOCAL_TASK,
    'description' => 'Edit Rollbacks',
    'page callback' => 'backdrop_get_form',
    'page arguments' => array('wordpress_rollback_edit_form'),
    'access arguments' => array('import wordpress blog'),
    'weight' => 2,
    );

  return $items;
}

/**
 * Implements hook_permission().
 *
 * @return array permissions
 **/
function wordpress_import_permission() {
  return array(
    'import wordpress blog' => array(
      'title' => t('Import wordpress blog'),
      'description' => t('Permission to import a wordpress blog.'),
    ),
  );
}

/**
 * Module entry point
 */
function wordpress_import_home() {

  // XMLReader is required.
  if (!extension_loaded('xmlreader')) {
    backdrop_set_message(t('<strong>XMLReader PHP extension not found!</strong>  The XMLReader extension is available in PECL as of PHP 5.0.0 and is included and enabled as of PHP 5.1.0 by default. It can be enabled by adding the argument --enable-xmlreader  (or --with-xmlreader before 5.1.0) to your configure line. The libxml  extension is required. '), 'error');
    return '';
  }

  return wordpress_import_wizard();
}

/**
 * Create and manage the multistep form
 */
function wordpress_import_wizard() {
  $step = arg(3);

  // *** SETUP ARRAY multistep setup ****
  $form_info = array(
    'id' => 'wordpress_import',
    'path' => "admin/content/wordpress_import/%step",
    'show trail' => TRUE,
    'show back' => FALSE,
    'show cancel' => TRUE,
    'show return' => FALSE,
    'next text' => t('Next'),
    'next callback' =>  'wordpress_import_form_subtask_next',
    'finish callback' => 'wordpress_import_form_subtask_finish',
    'return callback' => 'wordpress_import_form_subtask_finish',
    'cancel callback' => 'wordpress_import_form_subtask_cancel',
    'ajax' => FALSE,
   // This controls order, as well as form labels.
    'order' => array(
      'file' => t('Source file'),
      'options' => t('Options'),
      'taxonomy' => t('Map taxonomies'),
      'og' => t('Organic groups'),
      'mapusers' => t('Map users'),
      'newusers' => t('New users'),
      'ready' => t('Ready'),
    ),
   // Here we map a step to a form id.
    'forms' => array(
      'file' => array(
        'form id' => 'wordpress_import_form_file'
      ),
      'options' => array(
        'form id' => 'wordpress_import_form_options'
      ),
      'taxonomy' => array(
        'form id' => 'wordpress_import_form_map_taxonomies'
      ),
      'og' => array(
        'form id' => 'wordpress_import_form_og'
      ),
      'mapusers' => array(
        'form id' => 'wordpress_import_form_mapusers'
      ),
      'newusers' => array(
        'form id' => 'wordpress_import_form_newusers'
      ),
      'ready' => array(
        'form id' => 'wordpress_import_form_ready'
      ),
    ),
  );

  // *** SETTING THE FORM UP FOR MULTISTEP *** //
  $form_state = array(
    'cache name' => '',
  );

  $wordpress_import = wordpress_import_form_get_page_cache('');

  if (!$wordpress_import && $step != '') {
    backdrop_goto('admin/content/wordpress_import');
    return;
  }

  if (!$wordpress_import) {
    backdrop_set_message($step);
    $step = current(array_keys($form_info['order']));
    $wordpress_import = new stdClass();
    wordpress_import_form_set_page_cache($form_state['cache name'], $wordpress_import);
  }

  $form_state['wordpress_import_obj'] = $wordpress_import;

  // Skip taxonomy mapping form if taxonomy import is deselected.
  if ($step == 'taxonomy' && !!$wordpress_import->options['disable_categories']) {
    backdrop_goto('admin/content/wordpress_import/og');
  }

  // Skip OG step if module isn't present, or if content type isn't OG-enabled.
  if ($step == 'og' && (!module_exists('og') || !($wordpress_import->options['nodetype_post_og'] || $wordpress_import->options['nodetype_page_og']))) {
    backdrop_goto('admin/content/wordpress_import/mapusers');
  }

  // Skip user creation step if no new users.
  if ($step == 'newusers' && !array_search('newuser', $wordpress_import->usermap)) {
    backdrop_goto('admin/content/wordpress_import/ready');
  }

  $output = form_wizard_multistep_form($form_info, $step, $form_state);
  return $output;
}


/*---------------- Bachdrop cache handling functions ------------ */

/**
 * Remove an item from the object cache.
 */
function wordpress_import_form_clear_page_cache($name) {
  tempstore_clear('wordpress_import', $name);
}

/**
 * Get the cached changes to a given task handler.
 */
function wordpress_import_form_get_page_cache($name) {
  $cache = tempstore_get('wordpress_import', $name);
  return $cache;
}

/**
 * Store changes to a task handler in the object cache.
 */
function wordpress_import_form_set_page_cache($name, $page) {
  $cache = tempstore_set('wordpress_import', $name, $page, REQUEST_TIME + 3600);
}


/*-------------------------- Form Steps  ---------------------- */

/**
 * First form step:
 * Handling of the WXR file. Either upload a file or select
 * an already uploaded file stored in the created folder.
 */
function wordpress_import_form_file($form, &$form_state) {
  global $base_path;

  $wordpress_import = &$form_state['wordpress_import_obj'];

  $form['informations'] = array(
   '#value' => t('This module will import a WordPress eXtended RSS (WXR) file generated by WordPress. If you need instructions on creating this file, please read the  <a href="@codex">documentation</a>. <em>You should make a backup copy of your Backdrop database before proceeding!</em>', array('@codex' => url('https://wordpress.org/support/article/tools-export-screen/'))),
  );

  $form['import_id'] = array(
    '#type' => 'textfield',
    '#title' => t('Give this import a unique title.'),
    '#description' => t('Select a unique title to this import to detect it on rollback.'),
  );

  // Upload file form element.
  $form['upload'] = array(
    '#type' => 'file',
    '#title' => t('Upload your WXR file'),
    '#size' => 40,
    '#description' => t('The file can\'t exceed %maximum megabytes', array('%maximum' => $base_path . file_upload_max_size()/1024/1024)),
  );

  // Create and scan module directory.
  $directory = 'public://wordpress';
  $wordpress_import_path = backdrop_realpath($directory);
  $erg = file_prepare_directory($directory, FILE_CREATE_DIRECTORY);
  $files = file_scan_directory($wordpress_import_path, '/.*.xml$/i');

  if (count($files) > 0) {
    foreach ($files as $file) {
      $options[$file->filename] = $file->filename;
    }
    ksort($options);
    $description = '';
  }
  else {
    $options = array();
    $description = t('No files found in %directory', array('%directory' => file_create_url('files/wordpress')));
  }

  // Local file selector element.
  $form['local'] = array(
      '#title' => t('Or, alternatively, select a local WXR file'),
      '#type' => 'radios',
      '#description' => $description,
      '#options' => $options
    );

  $form['#attributes'] = array('enctype' => "multipart/form-data");

  return $form;
}


/**
 * Validation of the first form step.
 */
function wordpress_import_form_file_validate(&$form, &$form_state) {

  if ($form_state['clicked_button']['#wizard type'] == 'cancel') {
    return;
  }

  // Process uploaded file (if any), and set file path.
  $directory = 'public://wordpress';
  $validators = array('file_validate_extensions' => array('xml'));
  $upload = file_save_upload('upload', $validators, $directory);
  if ($upload) {
    $form_state['values']['upload'] = $upload->filename;
    $filepath = backdrop_realpath($upload->uri);
  }
  else {
    $filepath = backdrop_realpath('public://wordpress') . '/' . $form_state['values']['local'];
  }

  if (empty($form_state['values']['import_id'])) {
    form_set_error('import_id', t('You must specify a title for this import.'));
    return;
  }

  // Make sure a file was uploaded or a local file was selected.
  if (empty($form_state['values']['upload']) && empty($form_state['values']['local'])) {
    form_set_error('upload', t('You must specify a WXR file to upload or select a local WXR file. If you attempted to upload a file, the operation may have failed.'));
    return;
  }
  else {
    $form_state['wordpress_import_obj']->filepath = $filepath;
  }

  if (!wordpress_import_read_wxr($form_state['wordpress_import_obj'])) {
    form_set_error('upload', t('<strong>This file does not appear to be a valid WXR file.</strong> The file is either corrupted or invalid XML. In some versions of WordPress, the export function can produce malformed XML. Please see README.txt (included in the module archive) for further guidance.'));
  }

}


/**
 * Submit handler of the first form step.
 */
function wordpress_import_form_file_submit(&$form, &$form_state) {
  (!empty($form_state['values']['upload'])) ? ($filesource = t('uploaded')) : ($filesource = t('local'));
  $fileinfo = pathinfo($form_state['wordpress_import_obj']->filepath);

  backdrop_set_message(t('Successfully loaded @filesource file "@filename".', array('@filesource' => $filesource, '@filename' => $fileinfo['basename'])));

  $message = t('The following elements were identified :');

  $msg_found = array();
  $msg_found[] = '<li>' . t('@found_posts posts/pages', array('@found_posts' => $form_state['wordpress_import_obj']->count['posts'])) . '</li>';
  $msg_found[] = '<li>' . t('@found_comments comments', array('@found_comments' => $form_state['wordpress_import_obj']->count['comments'])) . '</li>';
  $msg_found[] = '<li>' . t('@found_authors authors', array('@found_authors' => count($form_state['wordpress_import_obj']->count['author_posts']))) . '</li>';
  $msg_found[] = '<li>' . t('@found_categories categories', array('@found_categories' => $form_state['wordpress_import_obj']->count['categories'])) . '</li>';
  $msg_found[] = '<li>' . t('@found_tags tags', array('@found_tags' => $form_state['wordpress_import_obj']->count['tags'])) . '</li>';

  backdrop_set_message($message . '<ul>' . join("\n", $msg_found) . '</ul>');

  // Create database entry.
  $iid = wordpress_import_db_create($form_state['values']['import_id']);
  $form_state['wordpress_import_obj']->import_id = $iid;
}


/**
 * Second form step:
 * Set options and advanced import options.
 * Options are:
 *     content type mapping
 *     language selection
 *     select, what to import
 *     choose creation of path alias or redirects
 */
function wordpress_import_form_options($form, &$form_state) {
  $wordpress_import = &$form_state['wordpress_import_obj'];

  $form['basic_options'] = array(
    '#type' => 'fieldset',
    '#title' => t('Options'),
    '#collapsible' => FALSE,
    '#tree' => TRUE
  );

  // Post content type.
  $node_types = node_type_get_types();
  $content_types = array('' => '', 'noimport' => t('Don\'t import'));
  foreach ($node_types as $k => $v) {
      if (!module_exists('og') || (module_exists('og') && !og_is_group_type($k))) {
        $content_types[$k] = $v->name;
      }
  }

  // Find text formats.
  $content_formats = array('' => '');
  $formats = filter_formats();
  foreach ($formats as $format) {
    $content_formats[$format->format] = $format->name;
  }

  // Find all menus.
  $available_menus = array('' => '') + menu_get_menus();

  $form['basic_options']['nodetype_post'] = array(
    '#type' => 'select',
    '#title' => t('Import posts in content type'),
    '#description' => t('All imported posts will be assigned the selected content type.'),
    '#default_value' => '',
    '#options' => $content_types,
    );
  $form['basic_options']['nodetype_post_format'] = array(
    '#type' => 'select',
    '#title' => t('Import posts in text format'),
    '#description' => t('All imported posts will be imported with the selected text format.'),
    '#default_value' => '',
    '#options' => $content_formats,
    );
  $form['basic_options']['nodetype_page'] = array(
    '#type' => 'select',
    '#title' => t('Import pages in content type'),
    '#description' => t('All imported pages will be assigned the selected content type.'),
    '#default_value' => '',
    '#options' => $content_types,
    );
  $form['basic_options']['nodetype_page_format'] = array(
    '#type' => 'select',
    '#title' => t('Import pages in text format'),
    '#description' => t('All imported pages will be imported with the selected text format.'),
    '#default_value' => '',
    '#options' => $content_formats,
    );

  $form['basic_options']['comments_format'] = array(
    '#type' => 'select',
    '#title' => t('Comments text format'),
    '#description' => t('Select the input format to use for imported comments.'),
    '#default_value' => '',
    '#options' => $content_formats,
  );

  $form['basic_options']['create_menu_items_page'] = array(
    '#type' => 'checkbox',
    '#title' => t('Create menu items for imported pages?'),
    '#default_value' => FALSE,
    '#disabled' => FALSE,
    '#description' => t('Check this box to if you want to create menu items for the imported pages'),
  );
  $form['basic_options']['create_menu_items_page_menu'] = array(
    '#type' => 'select',
    '#title' => t('Create menu item in menu'),
    '#description' => t('Select, in what menu the items should be created.'),
    '#default_value' => '',
    '#options' => $available_menus,
    );

  if (module_exists('locale')) {
    $default = language_default();
    $options = array('' => t('Language neutral'));
    $language_list = language_list();
    foreach ($language_list as $value) {
      $options[$value->langcode] = $value->name;
    }
    $form['basic_options']['language'] = array(
      '#type' => 'select',
      '#title' => t('Language'),
      '#default_value' => $default->langcode,
      '#options' => $options,
    );
  }

  $form['basic_options']['usermap_type'] = array(
      '#title' => t('User mapping'),
      '#type' => 'radios',
      '#description' => t('<strong>Single user</strong> will import all posts as one specified Backdrop user. <strong>Manual</strong> permits the mapping of an existing or new Backdrop user to each WordPress author.'),
      '#options' => array(
        'default' => t('Single user'),
        'manual' => t('Manual'))
    );

  $form['advanced_options'] = array(
    '#type' => 'fieldset',
    '#title' => t('Advanced options'),
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
    '#tree' => TRUE
  );

  $form['advanced_options']['disable_categories'] = array(
    '#type' => 'checkbox',
    '#title' => t('Don\'t import categories and tags'),
    '#default_value' => FALSE,
    '#disabled' => FALSE,
    '#description' => t('Check this box to disable import of categories and tags')
  );

  $form['advanced_options']['disable_comments'] = array(
    '#type' => 'checkbox',
    '#title' => t('Don\'t import comments'),
    '#default_value' => FALSE,
    '#disabled' => FALSE,
    '#description' => t('Check this box to disable import of comments')
  );

  $form['advanced_options']['disable_trackbacks'] = array(
    '#type' => 'checkbox',
    '#title' => t('Don\'t import trackbacks'),
    '#default_value' => FALSE,
    '#disabled' => FALSE,
    '#description' => t('Check this box to disable import of trackbacks')
  );

  $form['advanced_options']['aliases'] = array(
    '#type' => 'checkbox',
    '#title' => t('Create path aliases'),
    '#default_value' => FALSE,
    '#disabled' => FALSE,
    '#description' => t('Preserve the path of the original WordPress posts and pages. For this to work properly, your Backdrop site root must be the same as the WordPress site (!root) and clean URLs should be activated', array('!root' => $wordpress_import->data['baseurl']))
  );

  $form['advanced_options']['redirect'] = array(
    '#type' => 'checkbox',
    '#title' => t('Create URL redirect'),
    '#default_value' => FALSE,
    '#disabled' => FALSE,
    '#description' => t('Create an redirect of the original WordPress posts and pages URLs. For this to work properly, your Backdrop site root must be the same as the WordPress site (!root) and clean URLs should be activated', array('!root' => $wordpress_import->data['baseurl']))
  );


  $form['advanced_options']['images'] = array(
    '#type' => 'checkbox',
    '#title' => t('Transfer images'),
    '#default_value' => FALSE,
    '#description' => t('Try to download the images referenced in the blog posts locally')
  );

  $form['advanced_options']['images_dir'] = array(
    '#type' => 'textfield',
    '#title' => t('Images directory'),
    '#default_value' => '/wp_images',
    '#description' => t('Subdirectory of <strong>@wordpress_import_file_directory_path</strong> in which to place files, must start with /', array('@wordpress_import_file_directory_path' => wordpress_import_file_directory_path())),
  );

  // Warn if some key modules are not found.
  if (!module_exists('taxonomy')) {
      backdrop_set_message(t('Could not find module "taxonomy". <strong>Categories and tags will not be imported.</strong>'), 'error');
      $form['advanced_options']['disable_categories']['#default_value'] = TRUE;
      $form['advanced_options']['disable_categories']['#disabled'] = TRUE;
      $form['advanced_options']['#collapsed'] = FALSE;
  }
  if (!module_exists('comment')) {
      backdrop_set_message(t('Could not find module "comment". <strong>Comments and tackbacks will not be imported.</strong>'), 'error');
      $form['advanced_options']['disable_comments']['#default_value'] = TRUE;
      $form['advanced_options']['disable_comments']['#disabled'] = TRUE;
      $form['advanced_options']['#collapsed'] = FALSE;
  }
  if (!module_exists('trackback')) {
      backdrop_set_message(t('Could not find module "trackback". <strong>Trackbacks will not be imported.</strong>'), 'error');
      $form['advanced_options']['disable_trackbacks']['#default_value'] = TRUE;
      $form['advanced_options']['disable_trackbacks']['#disabled'] = TRUE;
      $form['advanced_options']['#collapsed'] = FALSE;
  }
  if (!module_exists('path')) {
      backdrop_set_message(t('Could not find module "path". Create paths option disabled.'), 'warning');
      $form['advanced_options']['aliases']['#default_value'] = FALSE;
      $form['advanced_options']['aliases']['#disabled'] = TRUE;
  }
  if (!module_exists('redirect')) {
      backdrop_set_message(t('Could not find module "redirect". Create redirect option disabled.'), 'warning');
      $form['advanced_options']['redirect']['#default_value'] = FALSE;
      $form['advanced_options']['redirect']['#disabled'] = TRUE;
  }
  if (!extension_loaded('curl')) {
      backdrop_set_message(t('cURL PHP extension not available. Transfer images option disabled.'), 'warning');
      $form['advanced_options']['images']['#default_value'] = FALSE;
      $form['advanced_options']['images']['#disabled'] = TRUE;
  }

  return $form;
}


/**
 * Validation of second form step.
 */
function wordpress_import_form_options_validate(&$form, &$form_state) {

  if ($form_state['clicked_button']['#wizard type'] == 'cancel') {
    return;
  }

  if (empty($form_state['values']['basic_options']['nodetype_post'])) {
    form_set_error('basic_options][nodetype', t('You must specify a content type to import WordPress posts into.'));
  }

  if (empty($form_state['values']['basic_options']['nodetype_page'])) {
    form_set_error('basic_options][nodetype', t('You must specify a content type to import WordPress pages into.'));
  }

  if ($form_state['values']['basic_options']['create_menu_items_page']
      && empty($form_state['values']['basic_options']['create_menu_items_page_menu'])) {
    form_set_error('basic_options][create_menu_items_page_menu', t('Please select the menu, where the item should be added'));
  }

  if (empty($form_state['values']['basic_options']['nodetype_post_format'])
      && $form_state['values']['basic_options']['nodetype_post'] != 'noimport') {
    form_set_error('basic_options][nodetype_post_format', t('You must specify a format to import WordPress posts into.'));
  }
  if (empty($form_state['values']['basic_options']['nodetype_page_format'])
      && $form_state['values']['basic_options']['nodetype_pagr'] != 'noimport') {
    form_set_error('basic_options][nodetype_page_format', t('You must specify a format to import WordPress posts into.'));
  }


  if (empty($form_state['values']['basic_options']['usermap_type'])) {
    form_set_error('basic_options][usermap_type', t('You must specify a user mapping method.'));
  }

  // Make sure that either path alias OR redirect is enabled.
  if ($form_state['values']['advanced_options']['aliases'] &&
      $form_state['values']['advanced_options']['redirect']) {
    form_set_error('advanced_options][aliases', t('Make sure that either path alias OR redirect is enabled.'));
    form_set_error('advanced_options][redirect', '');
  }

  $dir = '';
  // Test if images directory is valid.
  if ($form_state['values']['advanced_options']['images']) {
    $dir = wordpress_import_file_directory_path() . rtrim($form_state['values']['advanced_options']['images_dir'], '/\\');

    if (!is_dir($dir)) {
      if (!backdrop_mkdir($dir)) {
        form_set_error('advanced_options][images_dir', t('Invalid images directory specified.'));
        $form['advanced_options']['#collapsed'] = FALSE;
      }
    }
  }
  elseif (is_dir($dir)) {
    backdrop_rmdir($dir);
  }
}


/**
 * Submit handler of second form step.
 */
function wordpress_import_form_options_submit(&$form, &$form_state) {

  // Clear messages.
  backdrop_get_messages();

  $form_state['values']['advanced_options']['images_dir'] = wordpress_import_file_directory_path() . rtrim($form_state['values']['advanced_options']['images_dir'], '/\\');

  $options = $form_state['values']['basic_options'] + $form_state['values']['advanced_options'];
  $form_state['wordpress_import_obj']->options = $options;

  // Verify if chosen content types are OG-enabled.
  $form_state['wordpress_import_obj']->options['nodetype_post_og'] = FALSE;
  $form_state['wordpress_import_obj']->options['nodetype_page_og'] = FALSE;
  if (module_exists('og') && og_is_group_post_type($form_state['wordpress_import_obj']->options['nodetype_post'])) {
    $form_state['wordpress_import_obj']->options['nodetype_post_og'] = TRUE;
  }
  if (module_exists('og') && og_is_group_post_type($form_state['wordpress_import_obj']->options['nodetype_page'])) {
    $form_state['wordpress_import_obj']->options['nodetype_page_og'] = TRUE;
  }
}


/**
 * Third form step:
 *   Select mapping of the vocabularies.
 */
function wordpress_import_form_map_taxonomies($form, &$form_state) {
  $wordpress_import = &$form_state['wordpress_import_obj'];

  // Get the node types.
  $nodetype_post = $wordpress_import->options['nodetype_post'];
  $nodetype_page = $wordpress_import->options['nodetype_page'];

  // Get the fields of the node type.
  $nodetype_post_fields = field_info_instances('node', $nodetype_post);
  $nodetype_page_fields = field_info_instances('node', $nodetype_page);

  // Find the taxonomy-fields.
  $nodetype_post_taxonomy = array('noimport' => 'Do not import');
  $nodetype_page_taxonomy = array('noimport' => 'Do not import');

  foreach ($nodetype_post_fields as $field_name => $value) {
    $field_info = field_info_field($field_name);
    if (isset($field_info['type']) && ($field_info['type'] == 'taxonomy_term_reference')) {
      $nodetype_post_taxonomy[$field_name] = $value['label'];
    }
  }
/*
  foreach ($nodetype_page_fields as $field_name => $value) {
    $field_info = field_info_field($field_name);
    if (isset($field_info['type']) && ($field_info['type'] == 'taxonomy_term_reference')) {
      $nodetype_page_taxonomy[$field_name] = $value['label'];
    }
  }
*/
  $form['post_taxonomy_category'] = array(
    '#type' => 'select',
    '#title' => t('Import Category to vocabulary'),
    '#description' => t('All categories will be assigned to that vocabulary'),
    '#default_value' => 'noimport',
    '#options' => $nodetype_post_taxonomy,
  );

  $form['post_taxonomy_tags'] = array(
    '#type' => 'select',
    '#title' => t('Import Tags to vocabulary'),
    '#description' => t('All categories will be assigned to that vocabulary'),
    '#default_value' => 'noimport',
    '#options' => $nodetype_post_taxonomy,
  );
/*
  $form['page_taxonomy_category'] = array(
    '#type' => 'select',
    '#title' => t('Import Category to vocabulary'),
    '#description' => t('All categories will be assigned to that vocabulary'),
    '#default_value' => 'noimport',
    '#options' => $nodetype_page_taxonomy,
  );

  $form['page_taxonomy_tags'] = array(
    '#type' => 'select',
    '#title' => t('Import Tags to vocabulary'),
    '#description' => t('All categories will be assigned to that vocabulary'),
    '#default_value' => 'noimport',
    '#options' => $nodetype_page_taxonomy,
  );
*/
  return $form;
}


/**
 * Submit handler of third form step.
 */
function wordpress_import_form_map_taxonomies_submit(&$form, &$form_state) {

  $form_state['wordpress_import_obj']->options['nodetype_post_tm']['category_fieldname'] = $form_state['values']['post_taxonomy_category'];
  $form_state['wordpress_import_obj']->options['nodetype_post_tm']['tag_fieldname'] = $form_state['values']['post_taxonomy_tags'];

  // we additionally need to add the vocabulary name here
  $fn = $form_state['values']['post_taxonomy_category'];
  if ($fn != 'noimport') {
    $fi = field_info_field($fn);
    $form_state['wordpress_import_obj']->options['nodetype_post_tm']['category_vocabulary'] = $fi['settings']['allowed_values'][0]['vocabulary'];
  }

  $fn = $form_state['values']['post_taxonomy_tags'];
  if ($fn != 'noimport') {
    $fi = field_info_field($fn);
    $form_state['wordpress_import_obj']->options['nodetype_post_tm']['tag_vocabulary'] = $fi['settings']['allowed_values'][0]['vocabulary'];
  }

  /*
  $form_state['wordpress_import_obj']->options['nodetype_page_tm']['category_fieldname'] = $form_state['values']['page_taxonomy_category'];
  $form_state['wordpress_import_obj']->options['nodetype_page_tm']['tag_fieldname'] = $form_state['values']['page_taxonomy_tags'];
  */
}


/**
 * Fourth form step:
 * Settings for open graph. Not testet yet, because open graph is not yet
 * imported to backdrop.
 */
function wordpress_import_form_og($form, &$form_state) {
  $wordpress_import = &$form_state['wordpress_import_obj'];

  $form['informations'] = array(
   '#value' => t('You selected a content type which is also an OG group post node type. You may select OG parameters for the imported content.')
  );

  $form['og_nodeapi'] = array(
    '#type' => 'fieldset',
    '#title' => t('Organic groups'),
    '#collapsible' => FALSE,
    '#tree' => TRUE,
  );
  og_form_add_og_audience($form, $form_state);

  if (module_exists('og_access')) {
    $form['og_nodeapi']['og_public'] = array(
    '#type' => 'checkbox',
    '#title' => 'Public',
    '#description' => t('Show this post to everyone, or only to members of the groups checked above. Posts without any groups are always <em>public</em>.'),
    );
  }

  return $form;
}


/**
 * Submit handler for the open graph settings form.
 */
function wordpress_import_form_og_submit(&$form, &$form_state) {
  $form_state['wordpress_import_obj']->og_groups = $form_state['values']['og_nodeapi']['visible']['og_groups'];
  $form_state['wordpress_import_obj']->og_public = $form_state['values']['og_nodeapi']['og_public'];
}


/**
 * Form step five:
 *   Form for mapping imported user to existing user.
 */
function wordpress_import_form_mapusers($form, &$form_state) {
  $wordpress_import = &$form_state['wordpress_import_obj'];

  // Get Backdrop users.
  $sql = "SELECT u.uid, u.name FROM {users} u ORDER BY name ASC";
  $result =  db_query($sql);
  $found_users = $result->fetchAllAssoc('uid');

  foreach ($found_users as $backdrop_user) {
    if ($backdrop_user->uid != 0) {
      $backdrop_users[$backdrop_user->uid] = $backdrop_user->name;
    }
  }

  if ($wordpress_import->options['usermap_type'] == 'default') {

    $backdrop_users = array('newuser' => t('Create new user')) + $backdrop_users;

    $form['defaultuser'] = array(
      '#type' => 'select',
      '#title' => t('Default user'),
      '#description' => t('Map all WordPress authors to one single Backdrop user.'),
      '#options' => $backdrop_users,
    );

  }
  else {

    $backdrop_users = array('newuser' => t('Create new user'), 'noimport' => t('Do not import')) + $backdrop_users;

    $form['usermap'] = array(
      '#title' => t('Users mapping'),
      '#type' => 'fieldset',
      '#description' => t('Map each WordPress user to a distinct Backdrop user. The number of posts for each Worpress user is indicated next to the usernames.'),
      '#collapsible' => FALSE,
      '#tree' => TRUE
    );

    foreach ($wordpress_import->usermap as $wp_user => $backdrop_user) {
      $form['usermap'][$wp_user] = array(
        '#type' => 'select',
        '#title' => $wp_user . ' (' . $wordpress_import->count['author_posts'][$wp_user] . ')',
        '#options' => $backdrop_users,
      );
    }
  }

  return $form;
}


/**
 * Validation for form step five.
 */
function wordpress_import_form_mapusers_validate(&$form, &$form_state) {

  if ($form_state['clicked_button']['#wizard type'] == 'cancel') {
    return;
  }

  // Make sure there is something to import
  if (!empty($form_state['values']['usermap']) && count($form_state['values']['usermap']) > 0) {
    $i = FALSE;
    foreach ($form_state['values']['usermap'] as $wp_user => $backdrop_user) {
      if ($backdrop_user != 'noimport') {
        $i = TRUE;
        break;
      }
    }
    if (!$i) {
      form_set_error('usermap', t('Nothing to import!'));
    }
  }
  elseif (empty($form_state['values']['defaultuser'])) {
    form_set_error('defaultuser', t('Nothing to import!'));
  }
}


/**
 * Submit handler for form step five.
 */
function wordpress_import_form_mapusers_submit(&$form, &$form_state) {
  $wordpress_import = &$form_state['wordpress_import_obj'];

  if ($wordpress_import->options['usermap_type'] == 'default') {
    foreach ($wordpress_import->usermap as $key => $value) {
      $wordpress_import->usermap[$key] = $form_state['values']['defaultuser'];
    }
  }
  else {
    $wordpress_import->usermap = $form_state['values']['usermap'];
  }
}


/**
 * Form step six.
 * Form to create new user(s) if no mapping is wished.
 */
function wordpress_import_form_newusers($form, &$form_state) {
  $wordpress_import = &$form_state['wordpress_import_obj'];

  $form['newuser'] = array('#tree' => TRUE);

  if ($wordpress_import->options['usermap_type'] == 'default') {

    $form['newuser']['default'] = array('#type' => 'fieldset', '#title' => t('All WordPress authors'));
    $form['newuser']['default']['name'] = array('#type' => 'textfield', '#title' => t('Username for new user'));
    $form['newuser']['default']['mail'] = array('#type' => 'textfield', '#title' => t('E-mail address for new user'));
    $form['newuser']['default']['password'] = array('#type' => 'textfield', '#title' => t('Password for new user'));
  }
  else {
    foreach ($wordpress_import->usermap as $key => $value) {
      if ($value == 'newuser') {
        $form['newuser'][$key] = array('#type' => 'fieldset', '#title' => t('WordPress author %user', array('%user' => $key)));
        $form['newuser'][$key]['name'] = array('#type' => 'textfield', '#title' => t('Username for WordPress author %user', array('%user' => $key)), '#default_value' => $key);
        $form['newuser'][$key]['mail'] = array('#type' => 'textfield', '#title' => t('E-mail address for WordPress author %user', array('%user' => $key)));
        $form['newuser'][$key]['password'] = array('#type' => 'textfield', '#title' => t('Password for WordPress author %user', array('%user' => $key)));
      }
    }
  }

  return $form;
}


/**
 * Validation for form step six.
 */
function wordpress_import_form_newusers_validate(&$form, &$form_state) {

  if ($form_state['clicked_button']['#wizard type'] == 'cancel') {
    return;
  }

  $new_user_names = array();
  $new_user_mails = array();
  foreach ($form_state['values']['newuser'] as $key => $value) {
    // Check usernames.
    if ($error = user_validate_name($value['name'])) {
      form_set_error('newuser]['. $key .'][name', $error);
    }
    elseif (user_load_by_name($value['name'])) {
      form_set_error('newuser]['. $key .'][name', t('User !user already exists.', array('!user' => $value['name'])));
    }
    elseif (!empty($new_user_names) && in_array(strtolower($value['name']), $new_user_names)) {
      form_set_error('newuser]['. $key .'][name', t('Two users have the same name (!user).', array('!user' => $value['name'])));
    }

    // Check user emails.
    if (!valid_email_address($value['mail'])) {
      form_set_error('newuser]['. $key .'][mail', 'Thhis is not a valid email adress.');
    }
    elseif (user_load_by_mail($value['mail'])) {
      form_set_error('newuser]['. $key .'][mail', t('User with mail !mail already exists.', array('!mail' => $value['mail'])));
    }
    elseif (!empty($new_user_mails) && in_array(strtolower($value['mail']), $new_user_mails)) {
      form_set_error('newuser]['. $key .'][mail', t('Two users have the same mail (!mail).', array('!mail' => $value['mail'])));
    }

    $new_user_names[] = strtolower($value['name']);
    $new_user_mails[] = strtolower($value['mail']);
  }
}


/**
 * Submit handler for form step six.
 */
function wordpress_import_form_newusers_submit(&$form, &$form_state) {
  $form_state['wordpress_import_obj']->newuser = $form_state['values']['newuser'];
}


/**
 * The finish form. Lst form step.
 */
function wordpress_import_form_ready($form, &$form_state) {
  $wordpress_import = &$form_state['wordpress_import_obj'];

  $form['informations'] = array(
   '#value' => t('WordPress Import configuration is complete. Click "Finish" to launch the import process.'),
  );

  return $form;
}


/* ---------------- Form callback functions ---------------- */

/**
 * The callback function when the next button of a form step is clicked.
 *
 * @param  array &$form_state The stored values of the current form step.
 */
function wordpress_import_form_subtask_next(&$form_state) {
  $wordpress_import = &$form_state['wordpress_import_obj'];
  $cache = wordpress_import_form_set_page_cache($form_state['cache name'], $wordpress_import);
}


/**
 * The callback function when the cancel button of a form step is clicked.
 *
 * @param  array &$form_state The stored values of the current form step.
 */
function wordpress_import_form_subtask_cancel(&$form_state) {
  wordpress_import_form_clear_page_cache($form_state['cache name']);
  $form_state['redirect'] = 'admin/content/wordpress_import';
  backdrop_get_messages();
  backdrop_set_message('Import operation cancelled.');
}


/**
 * The callback function when the finish button of the last form step is clicked.
 *
 * @param  array &$form_state The stored values of the current form step.
 */
function wordpress_import_form_subtask_finish(&$form_state) {
  $wordpress_import = &$form_state['wordpress_import_obj'];
  wordpress_import_form_clear_page_cache($form_state['cache name']);

  // Prepare images directory.
  if ($wordpress_import->options['images'] && !empty($wordpress_import->options['images_dir'])) {
    file_prepare_directory($wordpress_import->options['images_dir'], TRUE);
  }

  // Prepare batch operations.
  $operations = array();
  $operations[] = array('wordpress_import_process_blog', array($wordpress_import));

  // Set up batch process.
  $batch = array(
    'operations' => $operations,
    'finished' => 'wordpress_import_batch_finished',
    'title' => t('WordPress import'),
    'init_message' => t('WordPress import is starting processing'),
    'progress_message' => t('Processed @current out of @total.'),
    'error_message' => t('WordPress import has encountered an error.'),
  );

  batch_set($batch);
  batch_process();

}

/**
 * Main batch import function.
 */
function wordpress_import_process_blog($wordpress_import, &$context) {

  // Initialize sandbox and results arrays to track important import info.
  if (empty($context['sandbox'])) {
    $context['sandbox']['vocab_done'] = FALSE;
    $context['sandbox']['users_done'] = FALSE;
    $context['sandbox']['format_done'] = FALSE;
    $context['sandbox']['progress'] = 0;
    $context['results']['created_users'] = 0;
    $context['results']['created_nodes'] = 0;
    $context['results']['created_terms'] = 0;
    $context['results']['created_categories'] = 0;
    $context['results']['downloaded_images'] = array();
    $context['results']['error_images'] = array();
    $context['results']['password_protected'] = 0;
    $context['results']['created_comments'] = 0;
    $context['results']['created_trackbacks'] = 0;
    $context['results']['created_items'] = array();

    // Store usermapping in context, because it seems to get lost here.
    $context['sandbox']['usermap'] = $wordpress_import->usermap;
  }

  // Create Backdrop terms for WordPress categories and tags.
  if (!$context['sandbox']['vocab_done'] && !$wordpress_import->options['disable_categories']) {
    wordpress_import_process_categories_tags($wordpress_import, $context);
    $context['sandbox']['vocab_done'] = TRUE;
  }

  // Create Backdrop users as needed.
  if (!$context['sandbox']['users_done']) {
      if ($wordpress_import->options['usermap_type'] == 'default' && !empty($wordpress_import->newuser['default'])) {

      // Create new default Backdrop user and assign uid to WordPress authors.
      // Check if a password is set.
      $password = empty($wordpress_import->newuser['default']['password']) ? user_password() : $wordpress_import->newuser['default']['password'];

      $defaultuser = new User();
      $defaultuser->mail = $wordpress_import->newuser['default']['mail'];
      $defaultuser->pass = $password;
      $defaultuser->name = $wordpress_import->newuser['default']['name'];
      $defaultuser->status = 1;

      $defaultuser = user_save($defaultuser);
      $context['results']['created_users']++;

      // Add user to created items for rollback.
      $context['results']['created_items'][] = array('user' => $defaultuser->uid);

      foreach ($wordpress_import->usermap as $key => $value) {
        $context['sandbox']['usermap'][$key] = $defaultuser->uid;
      }

    }
    elseif ($wordpress_import->options['usermap_type'] == 'manual' && count($wordpress_import->newuser) > 0) {

      // Create new Backdrop users as required and assign uid to corresponding
      // WordPress author.
      foreach ($wordpress_import->newuser as $key => $value) {

        $password = empty($value['password']) ? user_password() : $value['password'];

        $user = new User();
        $user->mail = $value['mail'];
        $user->pass = $password;
        $user->name = $value['name'];
        $user->isNew = TRUE;
        $user->status = 1;

        user_save($user);

        // Seems like we have to reload the user again.
        $user = user_load_by_mail($value['mail']);

        $context['sandbox']['usermap'][$key] = $user->uid;
        $context['results']['created_users']++;

        // Add user to created items for rollback.
        $context['results']['created_items'][] = array('user' => $user->uid);
      }
    }
    $context['sandbox']['users_done'] = TRUE;
  }

  // Get or create content format as needed.
  if (!$context['sandbox']['format_done']) {
    $wordpress_import->format = variable_get('wordpress_import_format_id', 0);
    if (!$wordpress_import->format || !filter_formats($wordpress_import->format)) {
      /*
      db_query("INSERT INTO {filter_formats} (name,cache) VALUES ('@s',1)", array('@s' => 'WordPress format'));
      $wordpress_import->format = db_result(db_query("SELECT MAX(format) AS format FROM {filter_formats}"));
      db_query("INSERT INTO {filters} (format, module, delta, weight) VALUES (@d1, '@s', @d2, @d3)", array('@d1' => $wordpress_import->format, '@s' => 'filter', '@d2' => 2, '@d3' => 0));
      variable_set('wordpress_import_format_id', $wordpress_import->format);
      */
    }
    $context['sandbox']['format_done'] = TRUE;
  }

  // Initialize XML stream-based parsing.
  $wordpress_import->reader = new XMLReader();
  $wordpress_import->reader->open($wordpress_import->filepath);

  // Limit number of posts imported per batch run.
  $limit = 10;

  // Skip already imported posts.
  $skip_imported = $context['sandbox']['progress'];

  while ($limit > 0 && $context['sandbox']['progress'] < $wordpress_import->count['posts']) {
    while ($wordpress_import->reader->read()) {
      if ($wordpress_import->reader->name == 'item' && $wordpress_import->reader->nodeType == XMLReader::ELEMENT) {
        if ($skip_imported > 0) {
          $wordpress_import->reader->next();
          $skip_imported--;
        }
        else {
          wordpress_import_process_post($wordpress_import, $context);
          $context['sandbox']['progress']++;
          $limit--;
          break;
        }
      }
    }
  }

  if ($context['sandbox']['progress'] < $wordpress_import->count['posts']) {
    $context['finished'] = $context['sandbox']['progress'] / ($wordpress_import->count['posts'] - 1);
  }

  $wordpress_import->reader->close();
}

/**
 * Import categories and tags as taxonomy terms
 */
function wordpress_import_process_categories_tags(&$wordpress_import, &$context) {
  if (!empty($wordpress_import->data['categories'])) {
    $wordpress_import->categories_vocabulary = $wordpress_import->options['nodetype_post_tm']['category_vocabulary'];
    $wordpress_import->categories_map = wordpress_import_get_terms($wordpress_import->options['nodetype_post_tm']['category_vocabulary']);
    foreach ($wordpress_import->data['categories'] as $category) {
      // Create term if it doesn't exist.
      if (empty($wordpress_import->categories_map[$category])) {
        $term = new TaxonomyTerm();
        $term->name = $category;
        $term->description = '';
        $term->vocabulary = $wordpress_import->options['nodetype_post_tm']['category_vocabulary'];
        $term->parent = 0;

        if (!empty($category['category_parent']) && !empty($wordpress_import->categories_map[$category['category_parent']])) {
          $term->parent = $wordpress_import->categories_map[$category['category_parent']];
        }
        taxonomy_term_save($term);
        $context['results']['created_items'][] = array('taxonomy_term' => $term->tid);

        // We need to insert the parent to the table manually.
        db_insert('taxonomy_term_hierarchy')
          ->fields(array(
            'tid' => $term->tid,
            'parent' => $term->parent,
            ))
          ->execute();

        $wordpress_import->categories_map[$category] = $term->tid;

        $context['results']['created_terms']++;
      }
    }
  }

  if (!empty($wordpress_import->data['tags'])) {

    $wordpress_import->tags_vocabulary = $wordpress_import->options['nodetype_post_tm']['tag_vocabulary'];
    $wordpress_import->tags_map = wordpress_import_get_terms($wordpress_import->options['nodetype_post_tm']['tag_vocabulary']);

    foreach ($wordpress_import->data['tags'] as $tag => $description) {

      // Create term if it doesn't exist.
      if (empty($wordpress_import->tags_map[$tag])) {
        $term = new TaxonomyTerm();
        $term->name = $tag;
        $term->description = $description;
        $term->vocabulary = $wordpress_import->tags_vocabulary;
        $term->parent = 0;

        taxonomy_term_save($term);
        $context['results']['created_items'][] = array('taxonomy_term' => $term->tid);

        // We need to insert the parent to the table manually.
        db_insert('taxonomy_term_hierarchy')
          ->fields(array(
            'tid' => $term->tid,
            'parent' => '0',
            ))
          ->execute();


        $wordpress_import->tags_map[$tag] = $term->tid;

        $context['results']['created_terms']++;
      }
    }
  }
}

/**
 * Process a WordPress post
 */
function wordpress_import_process_post(&$wordpress_import, &$context) {

  $reader = $wordpress_import->reader;
  $context['sandbox']['node_duplicate'] = FALSE;
  $context['sandbox']['post'] = array('categories' => array(), 'tags' => array(), 'comments' => array());
  $context['sandbox']['downloaded_images'] = array();
  $context['sandbox']['error_images'] = array();

  $post = & $context['sandbox']['post'];

  while ($reader->read() && !($reader->name == 'item' && $reader->nodeType == XMLReader::END_ELEMENT)) {
    if ($reader->nodeType == XMLReader::ELEMENT) {
      switch ($reader->name) {
        case 'title' :
          $reader->read();
          $post['title'] = $reader->value;
          break;
        case 'dc:creator' :
          $reader->read();
          $post['author'] = $reader->value;
          break;
        case 'wp:post_date' :
          $reader->read();
          $post['date'] = $reader->value;
          break;
        case 'wp:post_type' :
          $reader->read();
          $post['type'] = $reader->value;
          break;
        case 'wp:status' :
          $reader->read();
          $post['status'] = $reader->value;
          break;
        case 'wp:is_sticky' :
          $reader->read();
          $post['is_sticky'] = $reader->value;
          break;
        case 'wp:post_password' :
          $reader->read();
          $post['post_password'] = $reader->value;
          break;
        case 'content:encoded' :
          $reader->read();
          $post['content'] = $reader->value;
          break;
        case 'excerpt:encoded' :
          $reader->read();
          $post['excerpt'] = $reader->value;
          break;
        case 'link' :
          $reader->read();
          $post['link'] = $reader->value;
          break;
        case 'wp:comment_status' :
          $reader->read();
          $post['comment_status'] = $reader->value;
          break;
        case 'category' :
          if (!$wordpress_import->options['disable_categories']) {
            if ($reader->getAttribute('domain') == 'category') {
              $reader->read();
              $post['categories'][] = $reader->value;
            }
            elseif ($reader->getAttribute('domain') == 'post_tag') {
              $reader->read();
              $post['tags'][] = $reader->value;
            }
          }
          break;
        case 'wp:comment' :
          if (!$wordpress_import->options['disable_comments']) {
            $comment = array();
            while ($reader->read() && !($reader->name == 'wp:comment' && $reader->nodeType == XMLReader::END_ELEMENT)) {
              if ($reader->nodeType == XMLReader::ELEMENT) {
                $nodename = str_replace('wp:comment_', '', $reader->name);
                $reader->read();
                $comment[$nodename] = $reader->value;
              }
            }
            if (!empty($comment)) {
              $post['comments'][] = $comment;
            }
          }
          break;

        // Get the translations as stored by Stella plugin.
        case 'wp:postmeta':
          $reader->read();
          $reader->read();
          if ($reader->name == 'wp:meta_key') {
            $reader->read();
            if (strpos($reader->value, '_title') !== FALSE) {
              // Find the language.
              $components = explode('-', $reader->value);
              if (isset($components[1])) {
                $reader->read();
                $reader->read();
                $reader->read();
                $reader->read();
                $post['translations'][$components[1]]['title'] = $reader->value;
              }
            }
            if (strpos($reader->value, '_body') !== FALSE) {
              // Find the language.
              $components = explode('-', $reader->value);
              if (isset($components[1])) {
                $reader->read();
                $reader->read();
                $reader->read();
                $reader->read();
                $post['translations'][$components[1]]['body'] = $reader->value;
              }
            }

          }
          break;
      }
    }
  }

  // Node object setup ---------------------- //
  // $node = new Node();
  $node = array();
  $node_og = FALSE;

  // Node type.
  switch ($post['type']) {
    case 'post' :
      $node['type'] = $wordpress_import->options['nodetype_post'];
      $node_og = $wordpress_import->options['nodetype_post_og'];
      break;
    case 'page' :
      $node['type'] = $wordpress_import->options['nodetype_page'];
      $node_og = $wordpress_import->options['nodetype_page_og'];
      break;
    default :
      return;
  }

  $node = entity_create('node', $node);

  // Catch noimport content type flag.
  if ($node->type == 'noimport') {
    return;
  }

  // Node uid (return if we don't want this author).
  $node->uid = $context['sandbox']['usermap'][$post['author']];
  if ($node->uid == 'noimport' || !ctype_digit($node->uid)) {
    return;
  }

  // Node title.
  if (!empty($post['title'])) {
    $node->title = html_entity_decode($post['title'], ENT_COMPAT, 'UTF-8');
  }
  else {
    $node->title = t('Untitled');
  }

  // We need the language here.
  $node_language = (isset($wordpress_import->options['language']) ? $wordpress_import->options['language'] : LANGUAGE_NONE);

  $node->langcode = $node_language;

  $format = ($post['type'] == 'post') ? $wordpress_import->options['nodetype_post_format'] : $wordpress_import->options['nodetype_page_format'];

  // Process images for this post and replace URLs.
  if ($wordpress_import->options['images']) {
    wordpress_import_process_post_images($post['content'], $wordpress_import->options['images_dir'], $context);
  }

  // Node content.
  $node->body[LANGUAGE_NONE][0]['value'] = str_replace('<!--more-->', '<!--break-->', $post['content']);
  $node->body[LANGUAGE_NONE][0]['format'] =  $format;
  if (!empty($post['excerpt'])) {
    $node->body[LANGUAGE_NONE][0]['summary'] = $post['excerpt'];
  }

  // Node language.
  $node->language = $node_language;

  // Node timestamp.
  $node->created = strtotime($post['date']);
  $node->changed = $node->created;

  // Node status.
  switch ($post['status']) {
    case 'publish':
      if (empty($post['post_password'])) {
        $node->status = 1;
      }
      else {
        $node->status = 0;
        $context['results']['password_protected']++;
      }
      break;
    default:
      $node->status = 0;
  }

  // Node promote.
  switch ($post['is_sticky']) {
    case '1':
      $node->promote = 1;
      break;
    default:
      $node->promote = 0;
  }

  // Node comment status.
  $node->comment = $post['comment_status']=='open'? '2' : '0' ;

  // Check if node wasn't already imported.
  $temp_node = NULL;
  $node_exist = wordpress_import_has_node_duplicate($node);
  if ($node_exist) {
    // Load the node and add the comments.
    $temp_node = node_load($node_exist);
    if (module_exists('comment') && !empty($post['comments'])) {
      wordpress_import_process_post_comments($post['comments'], $temp_node->nid, $wordpress_import, $context);
    }
    node_save($temp_node);
    return;
  }

  $node_path = wordpress_import_process_post_link($post['link'], $wordpress_import->data['baseurl']);

  // Process link for this post.
  if (module_exists('path') && $wordpress_import->options['aliases']) {
    // Switch to Backdrop path.
    $path = array (
      'alias' => $node_path,
      'langcode' => $node->language,
      'auto' => FALSE,
    );

    $node->path = $path;
  }
  if (module_exists('taxonomy')) {
    if ($node->type == $wordpress_import->options['nodetype_post']) {
      if ($wordpress_import->options['nodetype_post_tm']['category_fieldname'] != 'noimport') {
        // Get the category term id and add it to the node.
        if (!empty($post['categories'])) {
          foreach ($post['categories'] as $key => $value) {
            $tid = wordpress_import_get_term_id($value, $wordpress_import->options['nodetype_post_tm']['category_vocabulary']);
            if ($tid) {
              $field_name = $wordpress_import->options['nodetype_post_tm']['category_fieldname'];
              if (!empty($node->{$field_name})) {
                $field = $node->{$field_name};
              }
              else {
                $field = array(
                  LANGUAGE_NONE => array(),
                );
              }
              $field[LANGUAGE_NONE][]['tid'] = $tid;
              $node->{$field_name} = $field;
            }
          }
        }
      }
      if ($wordpress_import->options['nodetype_post_tm']['tag_fieldname'] != 'noimport') {
        if (!empty($post['tags'])) {
          foreach ($post['tags'] as $key => $value) {
            $tid = wordpress_import_get_term_id($value, $wordpress_import->options['nodetype_post_tm']['tag_vocabulary']);
            if ($tid) {
              $field_name = $wordpress_import->options['nodetype_post_tm']['tag_fieldname'];
              if (!empty($node->{$field_name})) {
                $field = $node->{$field_name};
              }
              else {
                $field = array(
                  LANGUAGE_NONE => array(),
                );
              }
              $field[LANGUAGE_NONE][]['tid'] = $tid;
              $node->{$field_name} = $field;
            }
          }
        }
      }
    }
  }

  // Save the node.
  $result = node_save($node);
  $context['results']['created_items'][] = array('node' => $node->nid);

  // Process comments and trackbacks for this post.
  if (module_exists('comment') && !empty($post['comments'])) {
    wordpress_import_process_post_comments($post['comments'], $node->nid, $wordpress_import, $context);
  }

  // Create the translated nodes.
  if (isset($post['translations'])) {

    if ($temp_node != NULL) {
      // Node already exists, so switch.
      $node = $temp_node;
    }

    foreach ($post['translations'] as $key => $value) {
      // Process images for this post and replace URLs.
      if ($wordpress_import->options['images']) {
        wordpress_import_process_post_images($value['body'], $wordpress_import->options['images_dir'], $context);
      }

      $tn = new Node();
      $tn->type = $node->type;
      $tn->langcode = $key;
      $tn->title = $value['title'];
      $tn->uid = $node->uid;
      $tn->status = $node->status;
      $tn->created = $node->created;
      $tn->body[LANGUAGE_NONE][0]['value'] = str_replace('<!--more-->', '<!--break-->', $value['body']);
      $tn->body[LANGUAGE_NONE][0]['format'] = $format;
      $tn->comment = $node->comment;
      $tn->promote = $node->promote;
      $tn->sticky = $node->sticky;
      $tn->tnid = $node->nid;
      if (!$wordpress_import->options['redirect']  && $wordpress_import->options['aliases']) {
        $tn->path['alias'] = $node->path['alias'];
        $tn->path['auto'] = FALSE;
      }
      $tn->path['langcode'] = $key;
      if (isset($node->field_category)) {
        $tn->field_category = $node->field_category;
      }
      if (isset($node->field_tags)) {
        $tn->field_tags = $node->field_tags;
      }

      if (wordpress_import_has_node_duplicate($tn) === FALSE) {
        node_save($tn);
        $context['results']['created_nodes']++;
        $context['results']['created_items'][] = array('node' => $tn->nid);

        // Create redirect for the translated node.
        if (module_exists('redirect') && $wordpress_import->options['redirect']) {
          wordpress_import_create_redirect($tn, $node_path, $context);
        }

        // Create menu link if $node type is page and selected.
        if ($wordpress_import->options['create_menu_items_page']
            && $tn->type == $wordpress_import->options['nodetype_page']) {
          // here we have translated nodes, so use language in options
          $options = array();
          $language_list = language_list('enabled');
          if (isset($language_list[$tn->langcode])) {
            $options['language'] = $language_list[$tn->langcode];
          }
          wordpress_import_create_menu_link($tn, $wordpress_import->options['create_menu_items_page_menu'], $context, FALSE, $options);
        }

        // We need to set the tnid of the original node, too.
        if ($node->tnid != $node->nid) {
          $node->tnid = $node->nid;
          node_save($node);
        }
      }
    }
  }

  // Node OG parameters.
  if (module_exists('og') && $node_og) {
    $node->og_groups = $wordpress_import->og_groups;
    $node->og_public = (int) $wordpress_import->og_public;
    og_save_ancestry($node);
  }


  // Create redirect for this node.
  if (module_exists('redirect') && $wordpress_import->options['redirect']) {
    wordpress_import_create_redirect($node, $node_path, $context);

    // Also create a redirect with no language.
    wordpress_import_create_redirect($node, $node_path, $context, FALSE);
  }

  // Create menu link if $node type is page and selected.
  if ($wordpress_import->options['create_menu_items_page']
      && $node->type == $wordpress_import->options['nodetype_page']) {
    $options = array();
    if ($node->langcode != LANGUAGE_NONE) {
      $language_list = language_list('enabled');
      if (isset($language_list[$node->langcode])) {
        $options['language'] = $language_list[$node->langcode];
      }
    }
    wordpress_import_create_menu_link($node, $wordpress_import->options['create_menu_items_page_menu'], $context, FALSE, $options);
  }


  // Update messages infos with nid.
  if (!empty($context['sandbox']['downloaded_images']) || !empty($context['sandbox']['error_images'])) {
    foreach ($context['sandbox']['downloaded_images'] as $a) {
      $a['nid'] = $node->nid;
      $context['results']['downloaded_images'][] = $a;
    }
    foreach ($context['sandbox']['error_images'] as $a) {
      $a['nid'] = $node->nid;
      $a['title'] = $node->title;
      $context['results']['error_images'][] = $a;
    }
  }

  // Update the context.
  $context['results']['created_nodes']++;
  $context['message'] = t('Import in progress : @created - @title', array('@created' => format_date($node->created, 'small'), '@title' => $node->title));

  unset($context['sandbox']['post']);
  unset($context['sandbox']['downloaded_images']);
  unset($context['sandbox']['error_images']);

  // Store the new generated items to tempstore and make it valid for 3 days.
  wordpress_import_db_set($wordpress_import->import_id , $context['results']['created_items']);
}


/**
 * Process post link into node path.
 */
function wordpress_import_process_post_link($link, $baseurl) {

  $path = $link;
  $path = substr($path, strlen($baseurl));
  $path = rtrim($path, '/');

  // Find WordPress ugly permalinks and replace with Backdrop-style aliases.
  if (preg_match('/\?p=(\d+)/', $path, $id)) {
    $path = 'p/' . $id[1];
  }
  elseif (preg_match('/\?page_id=(\d+)/', $path, $id)) {
    $path = 'page_id/' . $id[1];
  }

  return $path;
}


/**
 * Process comments and trackbacks for this post
 */
function wordpress_import_process_post_comments($comments, $nid, $wordpress_import, &$context) {
  $node_duplicate = $context['sandbox']['node_duplicate'];

  $node_trackbacks = [];
  $node_comments = [];
  $comment_id = 0;

  foreach ($comments as $comment) {
    switch ($comment['approved']) {
      case '0':
        $status = COMMENT_NOT_PUBLISHED;
        break;
      case '1':
        $status = COMMENT_PUBLISHED;
        break;
      case 'spam':
        continue 2;
    }

    switch ($comment['type']) {
      case 'trackback':
        if (module_exists('trackback') && !$wordpress_import->options['disable_trackbacks']) {
          $node_trackback = [
            'nid' => $nid,
            'created' => strtotime($comment['date']),
            'changed' => strtotime($comment['date']),
            'site' => $comment['author_IP'],
            'name' => decode_entities(strip_tags($comment['author'])),
            'subject' => trim(truncate_utf8(decode_entities(strip_tags($comment['content'])), 29, TRUE)),
            'url' => $comment['author_url'],
            'excerpt' => $comment['content'],
            'status' => 1
          ];
          // Check if duplicate.
          if ($node_duplicate) {
            $tr = db_query("SELECT tr.trid FROM {trackback_received} tr WHERE tr.nid = %d AND tr.created = %d", $node_duplicate->nid, $node_trackback['created']);
            if ($tr->trid && $tr->excerpt == $node_trackback['excerpt']) {
              continue 2;
            }
            else {
              $node_trackbacks[$node_trackback['created']] = $node_trackback;
            }
          }
        }
        break;
      default:
        $nc = [
          'nid' => $nid,
          'pid' => 0,
          'subject' => trim(truncate_utf8(decode_entities(strip_tags($comment['content'])), 29, TRUE)),
          'name' => decode_entities(strip_tags(substr($comment['author'], 0, 60))),
          'mail' => $comment['author_email'],
          'homepage' => $comment['author_url'],
          'created' => strtotime($comment['date']),
          'changed' => strtotime($comment['date']),
          'hostname' => $comment['author_IP'],
          'status' => $status,
          'format' => $wordpress_import->options['comments_format'],
        ];

        $node_comment = entity_create('comment', $nc);
        $node_comment->comment_body[LANGUAGE_NONE][0]['value'] = $comment['content'];
        $node_comment->comment_body[LANGUAGE_NONE][0]['format'] = $wordpress_import->options['comments_format'];

        // Check if duplicate.
        if ($node_duplicate) {
          $c = db_query("SELECT c.cid, c.comment FROM {comments} c WHERE c.nid = %d AND c.timestamp = %d", $node_duplicate->nid, $node_comment['timestamp']);
          if ($c->cid && $c->comment == $node_comment['comment_body']) {
            continue 2;
          }
        }
        else {
          $node_comments[$node_comment->created] = $node_comment;
        }
        break;
    }
  }

  // Sort comments by timestamp so the thread won't be messed up in Backdrop.
  ksort($node_trackbacks);
  ksort($node_comments);

  // Save trackbacks.
  foreach ($node_trackbacks as $node_trackback) {
    db_query("INSERT INTO {trackback_received} (nid, created, site, name, subject, url, excerpt, status) VALUES (%d, %d, '%s', '%s', '%s', '%s', '%s', %d)",
      $node_trackback['nid'],
      $node_trackback['created'],
      $node_trackback['site'],
      $node_trackback['name'],
      $node_trackback['subject'],
      $node_trackback['url'],
      $node_trackback['excerpt'],
      $node_trackback['status']
    );
    $context['results']['created_trackbacks']++;
  }

  // Save comments.
  foreach ($node_comments as $node_comment) {
    $comment_id = comment_save($node_comment);
    if ($comment_id) {
      $context['results']['created_items'][] = ['comment' => $comment_id];
    }
    // Ensure that all variables are set and not null.
    if (isset($node_comment->hostname, $node_comment->created, $node_comment->status, $comment_id)) {
      // Prepare the query with placeholders.
      $query = "UPDATE {comment} SET hostname= :hn, created= :ts, status= :st WHERE cid= :id";
      $args = [
        ':hn' => $node_comment->hostname,
        ':ts' => $node_comment->created,
        ':st' => $node_comment->status,
        ':id' => $comment_id,
      ];

      // Execute the query.
      try {
        db_query($query, $args);
      }
      catch (Exception $e) {
        watchdog('wordpress_import', 'Failed to update comment: @error', ['@error' => $e->getMessage()], WATCHDOG_ERROR);
        // Optionally, handle the error, e.g., by skipping this comment or taking corrective action.
      }
    }
    else {
      watchdog('wordpress_import', 'Skipping comment update due to missing data', [], WATCHDOG_WARNING);
      // Handle missing data as appropriate for your application.
    }
  }
}

/**
 * Process node body and download image content
 */
function wordpress_import_process_post_images(&$body, $images_dir, &$context) {
  global $base_path;

  // Find image URL in content.
  preg_match_all('/(img|src)=("|\')[^"\'>]+/i', $body, $media);
  $imgdata = preg_replace('/(img|src)("|\'|="|=\')(.*)/i', "$3", $media[0]);

  foreach ($imgdata as $imgurl) {
    $urlinfo = parse_url($imgurl);
    $imginfo = pathinfo($urlinfo['path']);
    if (($urlinfo['scheme'] == 'http' || $urlinfo['scheme'] == 'https') && isset($imginfo['extension'])) {
      if ((strcasecmp($imginfo['extension'], 'jpg') == 0) ||
        (strcasecmp($imginfo['extension'], 'jpeg') == 0) ||
        (strcasecmp($imginfo['extension'], 'gif') == 0) ||
        (strcasecmp($imginfo['extension'], 'png') == 0)) {

        // Check if the image URL exists and is accessible
        $ch = curl_init($imgurl);
        curl_setopt($ch, CURLOPT_NOBODY, true);
        curl_exec($ch);
        $code = curl_getinfo($ch, CURLINFO_HTTP_CODE);
        curl_close($ch);

        if ($code == 200) { // HTTP status code 200 means the request was successful
          // Download image if it does not exist.
          $new_file_name = $images_dir . '/' . $imginfo['basename'];
          if (!file_exists($new_file_name)) {
            $file_contents = file_get_contents($imgurl);
            if ($file_contents !== FALSE) {
              $file = file_save_data($file_contents, "public://{$images_dir}/" . $imginfo['basename'], FILE_EXISTS_RENAME);
              if ($file) {
                // Assign the file as permanent to prevent it from being deleted automatically.
                $file->status = FILE_STATUS_PERMANENT;
                file_save($file);

                // Replace the old URL with the new local URL in the post content
                $newurl = file_create_url($file->uri);
                $body = str_replace($imgurl, $newurl, $body);

                // Assuming you have the node ID available here
                if (isset($context['sandbox']['nid']) && !empty($context['sandbox']['nid'])) {
                  $nid = $context['sandbox']['nid'];
                  file_usage_add($file, 'wordpress_import', 'node', $nid);
                } else {
                  // If the node ID isn't available, handle the error accordingly
                }

                // Add to the downloaded images list for reporting or further processing
                $context['sandbox']['downloaded_images'][] = array('oldurl' => $imgurl, 'newurl' => $newurl);
              } else {
                // Handle errors in saving the file
                $context['sandbox']['error_images'][] = array('oldurl' => $imgurl, 'message' => 'Error saving the file.');
              }
            } else {
              // Handle errors in getting the file contents
              $context['sandbox']['error_images'][] = array('oldurl' => $imgurl, 'message' => 'Error downloading the image.');
            }
          }
        } else {
          // Image URL is not accessible
          $context['sandbox']['error_images'][] = array('oldurl' => $imgurl, 'message' => 'Image URL not accessible.');
        }
      }
    }
  }
}



/**
 * Batch wrap-up function, displays import process results
 */
function wordpress_import_batch_finished($success, $results, $operations) {

  if ($success) {

    $message = t('Import successful : ');

    $msg_results = array();
    $msg_results[] = '<li>' . t('@created_nodes nodes', array('@created_nodes' => $results['created_nodes'])) . '</li>';
    $msg_results[] = '<li>' . t('@created_users users', array('@created_users' => $results['created_users'])) . '</li>';
    $msg_results[] = '<li>' . t('@created_terms taxonomy terms', array('@created_terms' => $results['created_terms'])) . '</li>';
    $msg_results[] = '<li>' . t('@created_comments comments', array('@created_comments' => $results['created_comments'])) . '</li>';
    $msg_results[] = '<li>' . t('@created_trackbacks trackbacks', array('@created_trackbacks' => $results['created_trackbacks'])) . '</li>';
    $msg_results[] = '<li>' . t('@downloaded_images/@total_images images', array('@downloaded_images' => count($results['downloaded_images']), '@total_images' => count($results['downloaded_images'])+count($results['error_images']))) . '</li>';

    backdrop_set_message($message . '<ul>' . join("\n", $msg_results) . '</ul>');

    if (count($results['error_images']) > 0) {

      $errors = '';
      foreach ($results['error_images'] as $error_image) {
        $errors .= '<li>' . l($error_image['title'], 'node/' . $error_image['nid']) . "</li>\n";
      }
      backdrop_set_message(t('Some images could not be transferred for these nodes :') . '<ul>' . $errors . '</ul>', 'warning');
    }

    if ($results['password_protected'] > 0) {
      backdrop_set_message(t('Encountered @password_protected password-protected posts. These were imported as unpublished nodes.', array('@password_protected' => $results['password_protected'])), 'warning');
    }

  }
  else {

    backdrop_set_message(t('Import failed.'), 'error');

  }

}


/* ---------------- Import utility functions ---------------- */

/**
 * Open WXR file in XMLReader and extract relevant data prior to import.
 */
function wordpress_import_read_wxr(&$wordpress_import) {

  $is_wxr_file = FALSE;
  $is_valid_xml = FALSE;

  $wordpress_import->data['categories'] = array();
  $wordpress_import->data['tags'] = array();
  $wordpress_import->usermap = array();
  $wordpress_import->count['posts'] = 0;
  $wordpress_import->count['author_posts'] = array();
  $wordpress_import->count['comments'] = 0;
  $wordpress_import->count['categories'] = 0;
  $wordpress_import->count['tags'] = 0;

  $reader = new XMLReader();
  $reader->open($wordpress_import->filepath);

  while ($reader->read()) {

    if ($reader->nodeType == XMLReader::ELEMENT) {

      // Check for WXR XML marker/
      // @todo: document why extra validation can't be performed, THERE IS NO DTD FOR WXR!
      if ($reader->name == 'rss') {
        $is_wxr_file = $reader->moveToAttribute('xmlns:wp');
      }

      if ($reader->name == 'wp:base_blog_url') {
        $reader->read();
        $wordpress_import->data['baseurl'] = $reader->value;
        if (substr($wordpress_import->data['baseurl'], -1) != '/') {
          $wordpress_import->data['baseurl'] .= '/';
        }
      }

      // Read posts data.
      if ($reader->name == 'item') {
        $reader->read();
        $wordpress_import->count['posts']++;
      }

      // Read categories data.
      if ($reader->name == 'category') {
        $domCategory = $reader->expand();
        foreach ($domCategory->childNodes as $node) {
          $wordpress_import->data['categories'][$node->nodeValue] = $node->nodeValue;
        }
        $wordpress_import->count['categories']++;
      }

      // Read tags data.
      if ($reader->name == 'wp:tag_name') {
        $reader->read();
        $tag_name = $reader->value;
        $wordpress_import->data['tags'][$tag_name] = '';
        while ($reader->read() && !($reader->name == 'wp:tag' && $reader->nodeType == XMLReader::END_ELEMENT)) {
            if ($reader->name == 'wp:tag_description' && $reader->nodeType == XMLReader::ELEMENT) {
                $reader->read();
                $wordpress_import->data['tags'][$tag_name] = $reader->value;
            }
        }
        $wordpress_import->count['tags']++;
      }

      // Read users data, create user map array.
      if ($reader->name == 'dc:creator') {
        $reader->read();
        $wordpress_import->usermap[$reader->value] = 0;
        if (empty($wordpress_import->count['author_posts'][$reader->value])) {
          // Define an index if we haven't started counting for this author yet.
          $wordpress_import->count['author_posts'][$reader->value] = 0;
        }
        $wordpress_import->count['author_posts'][$reader->value]++;
      }

      // Count comments.
      if ($reader->name == 'wp:comment') {
        $wordpress_import->count['comments']++;
      }
    }
    elseif ($reader->name == 'rss' && $reader->nodeType == XMLReader::END_ELEMENT) {
      // Reached the end of the document, we can safely assume valid XML.
      $is_valid_xml = TRUE;
    }
  }

  $reader->close();

  return $is_wxr_file && $is_valid_xml;
}


/**
 * Return an array of taxonomy terms belonging to a vocabulary
 */
function wordpress_import_get_terms($vocabulary) {
  $terms = taxonomy_get_tree($vocabulary);
  $term_map = array();
  foreach ($terms as $term) {
    $term_map[$term->name] = $term->tid;
  }

  return $term_map;
}


/**
 * Create a redirect for a node
 * @param  object  $node      The node object.
 * @param  string  $path      The redirect path.
 * @param  array   &$context  the batch context array.
 * @param  boolean $with_lang Indicator if the redirect has a language context.
 */
function wordpress_import_create_redirect($node, $path, &$context, $with_lang = TRUE) {
  $redirect = new Redirect();
  if ($with_lang) {
    $redirect->langcode = $node->langcode;
  }
  else {
    $redirect->langcode = LANGUAGE_NONE;
  }

  $redirect->source = $path;
  $redirect->redirect = 'node/' . $node->nid;;

  $result = redirect_save($redirect);
  if (($result == SAVED_NEW) || ($result == SAVED_UPDATED)) {
    $context['results']['created_items'][] = array('redirect' => $redirect->rid);
  }
}


/**
 * Create a menu link for a node.
 * @param  object  $node      The node bject.
 * @param  string  $menu_name The menu name the link is stored to.
 * @param  array   &$context  The batch context array.
 * @param  boolean $expanded  Not use. Menu expanded yes/no.
 * @param  array   $options   An array with options e.g. the language for the menu link.
 */
function wordpress_import_create_menu_link($node, $menu_name, &$context, $expanded = FALSE, $options = array()) {
  $item = array(
    'link_path' => 'node/' . $node->nid,
    'link_title' => empty($node->title) ? 'Untitled' : $node->title,
    'menu_name' => $menu_name,
    'options' => $options,
  );
  $mid = menu_link_save($item);
  if ($mid) {
    $context['results']['created_items'][] = array('menu_link' => $mid);
  }
}


/**
 * The form for the rollback.
 */
function wordpress_rollback_form($form, &$form_state) {

  $result = db_select('wordpress_import', 'w')
                    ->fields('w', array('iid', 'identifier'))
                    ->execute();

  $options = array();
  while($record = $result->fetchAssoc()) {
    $options[$record['iid']] = $record['identifier'];
  }

  $form['rollback_select'] = array(
    '#type' => 'radios',
    '#options' => $options,
    '#title' => t('Select the import you want to roll back.'),
  );
  $form['rollback_submit'] = array(
    '#type' => 'submit',
    '#value' => 'Rollback',
  );
  return $form;
}


/**
 * Submit handler for the rollback form.
 */
function wordpress_rollback_form_submit($form, &$form_state) {
  $selected_rollback = $form_state['values']['rollback_select'];

  if (!empty($selected_rollback)) {
    wordpress_import_rollback($selected_rollback);
  }
  else {
    backdrop_set_message('Please select a rollback', 'warning');
  }
}


/**
 * The edit form for rollbacks.
 */
function wordpress_rollback_edit_form($form, &$form_state) {

  $result = db_select('wordpress_import', 'w')
                    ->fields('w', array('iid', 'identifier'))
                    ->execute();

  $options = array();
  while($record = $result->fetchAssoc()) {
    $options[$record['iid']] = $record['identifier'];
  }

  $form['rollback_delete_select'] = array(
    '#type' => 'checkboxes',
    '#options' => $options,
    '#title' => t('Select the import you want to delete.'),
  );
  $form['rollback_submit'] = array(
    '#type' => 'submit',
    '#value' => 'Delete',
  );

  return $form;
}


/**
 * Submit handler for the rollback edit form.
 */
function wordpress_rollback_edit_form_submit($form, &$form_state) {
  $selected_rollback = $form_state['values']['rollback_delete_select'];

  $ids = array();
  foreach ($selected_rollback as $key => $value) {
    if ($value != 0) {
      $ids[] = $key;
    }
  }

  if (!empty($ids)) {
    wordpress_import_db_clear($ids);
  }
  else {
    backdrop_set_message('Please select a rollback', 'warning');
  }
}


/**
 * Process the rollback of the import in a batch.
 */
function wordpress_import_rollback($rollback_id) {

  $created_items = wordpress_import_db_get($rollback_id);
  if (empty($created_items)) {
    return;
  }

  // Setup the batch.
  $operations = array();
  $counter++;
  foreach ($created_items as $key => $value) {
    $item_type = key($value);
    $item_id = $value[$item_type];

    $operations[] = array(
      'wordpress_import_rollback_callback',
      array(
        $item_type,
        $item_id,
      ),
    );
  }

  $batch = array(
    'operations' => $operations,
    'finished' => 'wordpress_import_rollback_finished',
    'title' => t('WordPress import'),
    'init_message' => t('WordPress import rollback is starting processing'),
    'progress_message' => t('Processed @current out of @total.'),
    'error_message' => t('WordPress import has encountered an error.'),
  );
  batch_set($batch);
  batch_process('/admin/content/wordpress_import');
}


/**
 * Tha callback form for the rollback batch.
 * @param  string $item_type The item type to be deleted.
 * @param  string $item_id   The corresponding item id.
 * @param  array  &$context  The batch context array.
 */
function wordpress_import_rollback_callback($item_type, $item_id, &$context) {

  $function = $item_type . '_delete';
  if(function_exists($function)) {
    $function($item_id);
  }
}


/**
 * The finish callback for the rollback batch.
 */
function wordpress_import_rollback_finished($success, $results, $operations) {
  if ($success) {
    backdrop_set_message('Rollback successful');
  }
}


/**
 * cURL helper function since PHP has disabled redirection support.
 * Taken from http://www.php.net/manual/en/function.curl-setopt.php#71313
 */
function wordpress_import_curl_redir_url($ch) {
    static $curl_loops = 0;
    static $curl_max_loops = 20;
    if ($curl_loops++ >= $curl_max_loops) {
        $curl_loops = 0;
        return FALSE;
    }
    curl_setopt($ch, CURLOPT_HEADER, TRUE);
    curl_setopt($ch, CURLOPT_RETURNTRANSFER, TRUE);
    curl_setopt($ch, CURLOPT_NOBODY, TRUE);
    $header = curl_exec($ch);
    $http_code = curl_getinfo($ch, CURLINFO_HTTP_CODE);
    if ($http_code == 301 || $http_code == 302) {
        $matches = array();
        preg_match('/Location:(.*?)\n/', $header, $matches);
        $url = @parse_url(trim(array_pop($matches)));
        if (!$url) {
            // Couldn't process the url to redirect to.
            $curl_loops = 0;
            return FALSE;
        }
        $last_url = parse_url(curl_getinfo($ch, CURLINFO_EFFECTIVE_URL));
        if (!$url['scheme'])
            $url['scheme'] = $last_url['scheme'];
        if (!$url['host'])
            $url['host'] = $last_url['host'];
        if (!$url['path'])
            $url['path'] = $last_url['path'];
        $new_url = $url['scheme'] . '://' . $url['host'] . $url['path'] . ($url['query'] ? '?' . $url['query'] : '');
        curl_setopt($ch, CURLOPT_URL, $new_url);
        return wordpress_import_curl_redir_url($ch);
    }
    elseif ($http_code == 200) {
      $curl_loops = 0;
      return curl_getinfo($ch, CURLINFO_EFFECTIVE_URL);
    }
    else {
      $curl_loops = 0;
      return FALSE;
    }
}


/**
 * [wordpress_import_file_directory_path description]
 * @return string The public file path.
 */
function wordpress_import_file_directory_path() {
  return variable_get('file_public_path', conf_path() . '/files');
}


/**
 * Helper function to find duplicate nodes
 *
 * @param node $node the node to search for
 *
 * @return mixed FALSE if node is not found, nid otherwise.
 */
function wordpress_import_has_node_duplicate($node) {
  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'node');
  $query->propertyCondition('title', $node->title, '=');
  $query->propertyCondition('created', $node->created, '=');
  $query->propertyCondition('type', $node->type, '=');
  $query->propertyCondition('langcode', $node->langcode, '=');

  $ids = $query->execute();

  if (isset($ids['node'])) {
    $ids = array_keys($ids['node']);
    $id = array_shift($ids);
    return $id;
  }

  return FALSE;
}


/**
 * Helper function to find term id for a name
 *
 * @param string $$name the node to search for
 *
 * @return mixed FALSE if name is not found, tid otherwise.
 */
function wordpress_import_get_term_id($name, $vid) {
  $result = db_query('SELECT t.tid FROM {taxonomy_term_data} t WHERE t.name = :name AND t.vocabulary = :vocab', array(':name' => $name, ':vocab' => $vid))->fetchAll();

  return empty($result) ? FALSE : $result[0]->tid;
}


function wordpress_import_db_create($identifier) {
  $iid = db_insert('wordpress_import')
    ->fields(array(
      'identifier' => $identifier,
      'value' => serialize(array()),
    ))
    ->execute();

    return $iid;
}


/**
 * Helper function to store rollback information
 * @param  string $id    The import id.
 * @param  array  $value The value to be stored.
 */
function wordpress_import_db_set($id, $value) {
  db_update('wordpress_import')
    ->fields(array('value' => serialize($value)))
    ->condition('iid', $id)
    ->execute();
}

/**
 * Helper function to get a stored rollback.
 * @param  string $id The import id.
 * @return array      An array with the imported items.
 */
function wordpress_import_db_get($id) {
  $data = db_query('SELECT * FROM {wordpress_import} WHERE iid = :id', array(':id' => $id))->fetchObject();
  if ($data) {
    $data = unserialize($data->value);
  }
  return $data;
}

/**
 * Helper function to clear a stored rollback
 * @param  string $id The import id.
 */
function wordpress_import_db_clear($id) {
  db_delete('wordpress_import')
    ->condition('iid', ($id), 'IN')
    ->execute();
}
